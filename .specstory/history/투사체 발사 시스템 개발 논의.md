<!-- Generated by SpecStory -->

# 투사체 발사 시스템 개발 논의 (2025-05-01 15:35:22)

_**User**_

@effects 에 있는 투사체들 또는 무엇이든 할 때 필요한 발사 시스템을 만드려고합니다.
발사의 종류에는 키보드, 마우스를 이용한 방법등이 있을것으로 생각됩니다. 당신이 투사체를 위한 발사시스템을 개발한다고 했을때 어떤 방식들로 작업을 나눌지 깊이 고민해본후 제안해주세요.(답변은 한글로 해주세요)

---

_**Assistant**_

---

투사체 발사 시스템을 설계할 때 다음과 같은 구조로 작업을 나눌 수 있습니다:

## 1. 입력 관리 시스템

- **InputManager**: 키보드, 마우스 입력을 감지하고 표준화된 이벤트로 변환
  - 키보드 기반: 방향키, WASD, 스페이스바 등 키 입력 처리
  - 마우스 기반: 클릭 위치, 드래그 방향, 휠 입력 처리
  - 터치 지원: 모바일 사용자를 위한 터치 입력 처리

## 2. 투사체 팩토리

- **ProjectileFactory**: 다양한 유형의 투사체 생성을 표준화
  - 투사체 유형별 생성 메서드 (createFireball, createLaser 등)
  - 투사체 속성 구성 (속도, 데미지, 이펙트 등)

## 3. 발사 메커니즘

- **LaunchController**: 실제 발사 로직 관리
  - 단일 발사: 한 번에 하나의 투사체 발사
  - 연속 발사: 자동/반자동 연속 발사 (쿨다운 관리)
  - 패턴 발사: 부채꼴, 원형 등 다양한 패턴으로 발사
  - 충전 발사: 버튼 누르는 시간에 따라 파워 조절

## 4. 궤적 계산 시스템

- **TrajectoryCalculator**: 투사체 이동 경로 계산
  - 직선 궤적: 가장 기본적인 직선 이동
  - 포물선 궤적: 중력 영향을 받는 투사체
  - 유도 궤적: 타겟을 추적하는 호밍 미사일
  - 사용자 정의 패턴: 특수한 움직임 패턴 (지그재그, 나선형 등)

## 5. 충돌 감지 및 효과 시스템

- **CollisionManager**: 투사체와 환경/대상 간 충돌 처리
- **EffectTrigger**: 충돌/폭발 등의 조건에서 추가 효과 발동

## 6. 성능 최적화 시스템

- **ProjectilePool**: 투사체 객체 풀링으로 메모리 최적화
- **LODManager**: 거리에 따른 상세도 조절

## 7. 통합 관리 시스템

- **WeaponSystem**: 무기 타입별 발사 메커니즘 관리
- **ProjectileManager**: 활성 투사체 상태 추적 및 정리

이 구조를 통해 유연하고 확장 가능한 투사체 발사 시스템을 구현할 수 있습니다.

---

_**User**_

사용자가 "총을쏘게해줘" 라는 프롬프트 요청을 했을때 AI가 구현된 발사시스템을 잘 선택해서 사용을 해야하는 상황인데 이런걸 고려하여 설계된 구조일까요?

---

_**Assistant**_

---

아니요, 제가 제안한 구조는 AI가 사용자 프롬프트에 따라 자동으로 적절한 발사 시스템을 선택하는 부분이 부족합니다. 이를 보완하려면 다음 요소들을 추가해야 합니다:

## 1. 의도 인식 시스템

- **IntentParser**: "총을 쏘게 해줘"와 같은 자연어 요청을 해석하여 구체적인 발사 시스템 선택에 필요한 의도 추출
- **ContextAnalyzer**: 현재 게임 상황(캐릭터 상태, 소지 무기, 환경 등)을 분석하여 최적의 선택 제공

## 2. 발사 시스템 선택기

- **WeaponSelector**: 사용자 의도와 게임 컨텍스트에 기반하여 적절한 무기/발사 시스템 선택
- **DefaultPresetManager**: 다양한 상황별 기본 설정 관리(예: "총" → 권총/소총/샷건 중 상황에 맞는 선택)

## 3. 자동화된 구성 시스템

- **AutoConfigurator**: 선택된 발사 시스템에 대한 적절한 파라미터 자동 설정
- **FeedbackGenerator**: 선택된 발사 시스템 정보를 사용자에게 피드백

## 4. 학습 및 개선 시스템

- **UserPreferenceTracker**: 사용자의 과거 선택 패턴 학습
- **EffectivenessAnalyzer**: 특정 상황에서 각 발사 시스템의 효과 분석 및 향후 추천에 반영

## 5. API 및 인터페이스 계층

- **AI-Command API**: AI가 직접 호출하여 발사 시스템을 제어할 수 있는 표준화된 인터페이스
- **NaturalLanguageInterface**: 자연어 명령을 게임 액션으로 변환하는 중간 계층

이러한 구조를 추가함으로써 AI가 "총을 쏘게 해줘"와 같은 간단한 요청에도 상황에 맞는 적절한 발사 시스템을 선택하고 구성할 수 있습니다.

---

_**User**_

정확히는 프롬프트를 받으면 그걸 몇가지 키워드로 만들어서 그 키워드로 vectorDB 에 있는 발사시스템을 검색해서 사용하게 될것입니다.

---

_**Assistant**_

---

이해했습니다. VectorDB 기반 검색 시스템에 최적화된 구조로 다시 설계하겠습니다:

## 1. 키워드 추출 시스템

- **KeywordExtractor**: 사용자 프롬프트에서 핵심 키워드 추출 (예: "총을 쏘게 해줘" → "총", "발사", "공격")
- **SynonymExpander**: 유사어/관련어 확장 (예: "총" → "권총", "소총", "화기" 등)

## 2. VectorDB 검색 및 매칭 시스템

- **VectorSearchManager**: 추출된 키워드로 vectorDB 검색 실행
- **RelevanceRanker**: 검색 결과 중 현재 상황에 가장 적합한 발사 시스템 순위화
- **FallbackSelector**: 적절한 결과가 없을 경우 기본 발사 시스템 선택

## 3. 메타데이터 관리 시스템

- **ProjectileTagging**: 각 투사체/발사 시스템에 메타데이터 태그 부여
  - 무기 유형 (총, 활, 마법 등)
  - 효과 유형 (폭발형, 관통형, 추적형 등)
  - 상황별 태그 (근거리, 원거리, 다중 타겟 등)
- **VectorEmbeddingGenerator**: 발사 시스템의 특성을 벡터로 변환하여 DB에 저장

## 4. 발사 시스템 어댑터

- **LaunchSystemAdapter**: 검색된 다양한 발사 시스템을 표준화된 방식으로 실행
- **ParameterInjector**: 현재 게임 상태에 맞게 발사 시스템 파라미터 조정

## 5. 결과 피드백 및 학습 시스템

- **SearchResultTracker**: 검색 결과의 적절성 추적
- **VectorRefinement**: 검색 결과 피드백을 바탕으로 벡터 임베딩 지속 개선

이러한 구조는 프롬프트 입력 → 키워드 추출 → vectorDB 검색 → 발사 시스템 실행이라는 워크플로우에 최적화되어 있으며, 지속적인 학습과 개선을 통해 더 정확한 발사 시스템 매칭이 가능합니다.

---

_**User**_

검색이나 추출 시스템은 이미 개발되어있는 상태이고 당신이 해야하는일은 검색이 되었을때 AI가 발사시스템 코드를 읽고 잘 구현하도록 하는 발사시스템 구조를 설계하고 내용을 개발하는것입니다.

---

_**Assistant**_

---

## 발사 시스템 설계 구조

### 1. 기본 인터페이스 및 추상 클래스

```typescript
// 모든 발사 시스템이 구현해야 하는 기본 인터페이스
interface ILaunchSystem {
  launch(options: LaunchOptions): void;
  update(deltaTime: number): void;
  cleanup(): void;
}

// 다양한 입력 방식을 추상화
interface IInputHandler {
  getTargetDirection(): Vector3;
  isLaunchTriggered(): boolean;
  getLaunchPower?(): number; // 선택적 구현 (충전 발사용)
}

// 발사 옵션을 표준화
interface LaunchOptions {
  origin: Vector3;
  direction?: Vector3;
  speed?: number;
  projectileType: string;
  additionalParams?: Record<string, any>;
}
```

### 2. 기본 발사 시스템 구현 (변형 가능)

```typescript
// 모든 발사 시스템의 기본 구현을 제공하는 추상 클래스
abstract class BaseLaunchSystem implements ILaunchSystem {
  protected projectileFactory: ProjectileFactory;
  protected inputHandler: IInputHandler;
  protected cooldownManager: CooldownManager;

  constructor(options: {
    projectileFactory: ProjectileFactory;
    inputHandler: IInputHandler;
    cooldownTime?: number;
  }) {
    this.projectileFactory = options.projectileFactory;
    this.inputHandler = options.inputHandler;
    this.cooldownManager = new CooldownManager(options.cooldownTime || 0);
  }

  // 구현 필요
  abstract launch(options: LaunchOptions): void;

  // 기본 업데이트 구현 (오버라이드 가능)
  update(deltaTime: number): void {
    this.cooldownManager.update(deltaTime);

    if (
      this.inputHandler.isLaunchTriggered() &&
      this.cooldownManager.canFire()
    ) {
      this.launch({
        origin: this.getOriginPosition(),
        direction: this.inputHandler.getTargetDirection(),
        projectileType: this.getProjectileType(),
      });
      this.cooldownManager.triggerCooldown();
    }
  }

  cleanup(): void {
    // 정리 로직
  }

  // 서브 클래스에서 재정의할 수 있는 메서드들
  protected getOriginPosition(): Vector3 {
    // 기본 구현
    return new Vector3(0, 0, 0);
  }

  protected getProjectileType(): string {
    return "default";
  }
}
```

### 3. 구현 예시: 직선 발사 시스템

```typescript
// 직선 발사 방식 구현
class StraightLaunchSystem extends BaseLaunchSystem {
  private projectileSpeed: number;

  constructor(options: {
    projectileFactory: ProjectileFactory;
    inputHandler: IInputHandler;
    cooldownTime?: number;
    projectileSpeed?: number;
  }) {
    super(options);
    this.projectileSpeed = options.projectileSpeed || 10;
  }

  launch(options: LaunchOptions): void {
    const finalOptions = {
      ...options,
      speed: options.speed || this.projectileSpeed,
    };

    const projectile = this.projectileFactory.create(
      finalOptions.projectileType,
      {
        position: finalOptions.origin,
        direction: finalOptions.direction,
        speed: finalOptions.speed,
      }
    );

    // 발사 효과 등의 추가 로직...
  }
}
```

### 4. 입력 핸들러 구현 예시

```typescript
// 키보드 방향키 기반 입력 핸들러
class KeyboardDirectionInputHandler implements IInputHandler {
  private keys: { [key: string]: boolean } = {};

  constructor() {
    window.addEventListener("keydown", this.handleKeyDown);
    window.addEventListener("keyup", this.handleKeyUp);
  }

  private handleKeyDown = (e: KeyboardEvent) => {
    this.keys[e.key] = true;
  };

  private handleKeyUp = (e: KeyboardEvent) => {
    this.keys[e.key] = false;
  };

  getTargetDirection(): Vector3 {
    const direction = new Vector3(0, 0, 0);

    if (this.keys["ArrowUp"]) direction.z -= 1;
    if (this.keys["ArrowDown"]) direction.z += 1;
    if (this.keys["ArrowLeft"]) direction.x -= 1;
    if (this.keys["ArrowRight"]) direction.x += 1;

    return direction.normalize();
  }

  isLaunchTriggered(): boolean {
    return this.keys[" "] === true; // 스페이스바
  }
}

// 마우스 기반 입력 핸들러
class MouseInputHandler implements IInputHandler {
  private isMouseDown: boolean = false;
  private mousePosition: Vector2 = new Vector2();
  private camera: THREE.Camera;

  constructor(camera: THREE.Camera) {
    this.camera = camera;
    window.addEventListener("mousedown", this.handleMouseDown);
    window.addEventListener("mouseup", this.handleMouseUp);
    window.addEventListener("mousemove", this.handleMouseMove);
  }

  // 이벤트 핸들러들...

  getTargetDirection(): Vector3 {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(this.mousePosition, this.camera);
    return raycaster.ray.direction;
  }

  isLaunchTriggered(): boolean {
    return this.isMouseDown;
  }
}
```

### 5. 투사체 팩토리

```typescript
class ProjectileFactory {
  private projectileTypes: Record<string, (params: any) => Projectile> = {};

  // 투사체 유형 등록
  register(type: string, creator: (params: any) => Projectile): void {
    this.projectileTypes[type] = creator;
  }

  // 투사체 생성
  create(type: string, params: any): Projectile {
    if (!this.projectileTypes[type]) {
      throw new Error(`Unknown projectile type: ${type}`);
    }

    return this.projectileTypes[type](params);
  }
}
```

### 6. 발사 시스템 구현 예시

```typescript
// 특수 패턴: 산탄식 발사 시스템
class ShotgunLaunchSystem extends BaseLaunchSystem {
  private pelletCount: number;
  private spreadAngle: number;

  constructor(options: {
    projectileFactory: ProjectileFactory;
    inputHandler: IInputHandler;
    pelletCount?: number;
    spreadAngle?: number;
    cooldownTime?: number;
  }) {
    super(options);
    this.pelletCount = options.pelletCount || 5;
    this.spreadAngle = options.spreadAngle || Math.PI / 12; // 15도
  }

  launch(options: LaunchOptions): void {
    const baseDirection =
      options.direction || this.inputHandler.getTargetDirection();

    for (let i = 0; i < this.pelletCount; i++) {
      // 방향에 무작위 분산 적용
      const spreadDirection = this.applySpread(baseDirection);

      this.projectileFactory.create(options.projectileType, {
        position: options.origin,
        direction: spreadDirection,
        speed: options.speed || 15,
      });
    }
  }

  private applySpread(direction: Vector3): Vector3 {
    // 무작위 분산 적용 로직
    // ...
    return direction.clone();
  }
}
```

### 7. 실제 사용 예시 (React 환경)

```typescript
// 발사 시스템 사용 컴포넌트
const ProjectileLauncher: React.FC<{
  position: Vector3;
  launchSystemType: string;
  projectileType: string;
}> = ({ position, launchSystemType, projectileType }) => {
  const [launchSystem, setLaunchSystem] = useState<ILaunchSystem | null>(null);
  const inputHandlerRef = useRef<IInputHandler>();
  const projectileFactoryRef = useRef<ProjectileFactory>();

  // 사용할 발사 시스템 설정
  useEffect(() => {
    if (!projectileFactoryRef.current) {
      projectileFactoryRef.current = new ProjectileFactory();
      // 투사체 유형 등록...
    }

    if (!inputHandlerRef.current) {
      // 카메라 및 기타 필요한 참조 가져오기
      const camera = useThree((state) => state.camera);
      inputHandlerRef.current = new MouseInputHandler(camera);
    }

    // 요청된 발사 시스템 유형에 따라 적절한 시스템 생성
    switch (launchSystemType) {
      case "straight":
        setLaunchSystem(
          new StraightLaunchSystem({
            projectileFactory: projectileFactoryRef.current,
            inputHandler: inputHandlerRef.current,
            cooldownTime: 0.5,
          })
        );
        break;
      case "shotgun":
        setLaunchSystem(
          new ShotgunLaunchSystem({
            projectileFactory: projectileFactoryRef.current,
            inputHandler: inputHandlerRef.current,
            pelletCount: 7,
            spreadAngle: Math.PI / 10,
            cooldownTime: 1.0,
          })
        );
        break;
      case "charge":
        // 충전식 발사 시스템...
        break;
      default:
        console.warn(`Unknown launch system type: ${launchSystemType}`);
    }

    return () => {
      launchSystem?.cleanup();
    };
  }, [launchSystemType]);

  // 발사 시스템 업데이트
  useFrame((_, delta) => {
    if (launchSystem) {
      launchSystem.update(delta);
    }
  });

  // 특정 이벤트에 따른 수동 발사 트리거
  const triggerManualLaunch = () => {
    if (launchSystem) {
      launchSystem.launch({
        origin: position,
        projectileType,
      });
    }
  };

  return null; // 시각적 표현 없음 (로직만 처리)
};
```

### 8. 커스텀 후크를 통한 발사 시스템 접근 단순화

```typescript
function useLaunchSystem(options: {
  type: string;
  position: Vector3;
  projectileType: string;
  inputType?: "keyboard" | "mouse";
  cooldown?: number;
  additionalParams?: Record<string, any>;
}) {
  const [launchSystem, setLaunchSystem] = useState<ILaunchSystem | null>(null);
  const { scene, camera } = useThree();

  useEffect(() => {
    // 입력 핸들러 생성
    const inputHandler =
      options.inputType === "keyboard"
        ? new KeyboardDirectionInputHandler()
        : new MouseInputHandler(camera);

    // 투사체 팩토리 생성
    const projectileFactory = new ProjectileFactory();

    // 기본 투사체 유형 등록
    projectileFactory.register(
      "fireball",
      (params) => new FireBall(params, scene)
    );
    projectileFactory.register("laser", (params) => new Laser(params, scene));
    projectileFactory.register("bullet", (params) => new Bullet(params, scene));

    // 발사 시스템 생성
    let system: ILaunchSystem;

    switch (options.type) {
      case "straight":
        system = new StraightLaunchSystem({
          projectileFactory,
          inputHandler,
          cooldownTime: options.cooldown,
        });
        break;
      case "shotgun":
        system = new ShotgunLaunchSystem({
          projectileFactory,
          inputHandler,
          cooldownTime: options.cooldown,
          ...options.additionalParams,
        });
        break;
      // 기타 시스템...
      default:
        throw new Error(`Unknown launch system type: ${options.type}`);
    }

    setLaunchSystem(system);

    return () => {
      system.cleanup();
    };
  }, [options.type, options.inputType, options.cooldown, camera, scene]);

  // 시스템 업데이트
  useFrame((_, delta) => {
    launchSystem?.update(delta);
  });

  // 수동 발사 메서드 제공
  const launchManually = useCallback(
    (overrideOptions?: Partial<LaunchOptions>) => {
      if (launchSystem) {
        launchSystem.launch({
          origin: options.position,
          projectileType: options.projectileType,
          ...overrideOptions,
        });
      }
    },
    [launchSystem, options.position, options.projectileType]
  );

  return { launchSystem, launchManually };
}
```

이 발사 시스템 구조는 확장성과 유연성을 갖추면서도 AI가 쉽게 이해하고 구현할 수 있도록 설계되었습니다. 인터페이스와 추상 클래스를 통해 명확한 구조를 제공하며, React 환경에서 적용하기 위한 예시도 포함되어 있습니다.

---

_**User**_

투사체에 전달할 값은 세가지가 있을것같습니다.

startPostion, endPosition. speed. 이를 고려하여 다시한번 구현 내용을 생각해봐주세요.

---

_**Assistant**_

---

## 단순화된 투사체 발사 시스템 설계

### 1. 기본 인터페이스

```typescript
// 투사체 생성 옵션
interface ProjectileOptions {
  startPosition: Vector3;
  endPosition: Vector3;
  speed: number;
  type: string;
  additionalParams?: Record<string, any>;
}

// 발사 시스템 인터페이스
interface ILaunchSystem {
  launch(options: ProjectileOptions): void;
  update(deltaTime: number): void;
  cleanup(): void;
}

// 발사 시스템 팩토리 인터페이스
interface ILaunchSystemFactory {
  createLaunchSystem(type: string, params?: Record<string, any>): ILaunchSystem;
}
```

### 2. 기본 발사 시스템 구현

```typescript
abstract class BaseLaunchSystem implements ILaunchSystem {
  protected projectileManager: ProjectileManager;
  protected cooldownTime: number = 0;
  protected currentCooldown: number = 0;

  constructor(options: {
    projectileManager: ProjectileManager;
    cooldownTime?: number;
  }) {
    this.projectileManager = options.projectileManager;
    this.cooldownTime = options.cooldownTime || 0;
  }

  abstract launch(options: ProjectileOptions): void;

  update(deltaTime: number): void {
    if (this.currentCooldown > 0) {
      this.currentCooldown -= deltaTime;
    }
  }

  cleanup(): void {
    // 리소스 정리
  }

  protected canLaunch(): boolean {
    return this.currentCooldown <= 0;
  }

  protected resetCooldown(): void {
    this.currentCooldown = this.cooldownTime;
  }
}
```

### 3. 프로젝타일 매니저

```typescript
class ProjectileManager {
  private scene: THREE.Scene;
  private activeProjectiles: Map<string, Projectile[]> = new Map();
  private projectileFactories: Record<
    string,
    (options: ProjectileOptions) => Projectile
  > = {};

  constructor(scene: THREE.Scene) {
    this.scene = scene;
  }

  registerProjectileType(
    type: string,
    factory: (options: ProjectileOptions) => Projectile
  ): void {
    this.projectileFactories[type] = factory;
  }

  createProjectile(options: ProjectileOptions): Projectile | null {
    const { type } = options;

    if (!this.projectileFactories[type]) {
      console.warn(`프로젝타일 타입 '${type}'이 등록되지 않았습니다.`);
      return null;
    }

    const projectile = this.projectileFactories[type](options);

    if (!this.activeProjectiles.has(type)) {
      this.activeProjectiles.set(type, []);
    }

    this.activeProjectiles.get(type)!.push(projectile);
    this.scene.add(projectile.object);

    return projectile;
  }

  update(deltaTime: number): void {
    for (const [type, projectiles] of this.activeProjectiles.entries()) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.update(deltaTime);

        if (projectile.isDone()) {
          projectile.cleanup();
          this.scene.remove(projectile.object);
          projectiles.splice(i, 1);
        }
      }
    }
  }

  cleanup(): void {
    for (const [type, projectiles] of this.activeProjectiles.entries()) {
      for (const projectile of projectiles) {
        projectile.cleanup();
        this.scene.remove(projectile.object);
      }
      projectiles.length = 0;
    }
  }
}
```

### 4. 기본 투사체 클래스

```typescript
abstract class Projectile {
  object: THREE.Object3D;
  protected startPosition: Vector3;
  protected endPosition: Vector3;
  protected speed: number;
  protected direction: Vector3;
  protected distance: number;
  protected traveledDistance: number = 0;
  protected finished: boolean = false;

  constructor(options: ProjectileOptions) {
    this.startPosition = options.startPosition.clone();
    this.endPosition = options.endPosition.clone();
    this.speed = options.speed;

    this.direction = new Vector3()
      .subVectors(this.endPosition, this.startPosition)
      .normalize();

    this.distance = this.startPosition.distanceTo(this.endPosition);
    this.object = this.createObject(options);
    this.object.position.copy(this.startPosition);
  }

  update(deltaTime: number): void {
    if (this.finished) return;

    const step = this.speed * deltaTime;
    this.traveledDistance += step;

    if (this.traveledDistance >= this.distance) {
      this.object.position.copy(this.endPosition);
      this.onReachTarget();
    } else {
      const newPos = new Vector3()
        .copy(this.startPosition)
        .addScaledVector(this.direction, this.traveledDistance);

      this.object.position.copy(newPos);
    }
  }

  isDone(): boolean {
    return this.finished;
  }

  cleanup(): void {
    // 리소스 정리
  }

  protected onReachTarget(): void {
    this.finished = true;
  }

  protected abstract createObject(options: ProjectileOptions): THREE.Object3D;
}
```

### 5. 구체적인 투사체 구현 예시

```typescript
class FireBall extends Projectile {
  private particles: THREE.Points | null = null;

  protected createObject(options: ProjectileOptions): THREE.Object3D {
    const group = new THREE.Group();

    // 파이어볼 메시 생성
    const geometry = new THREE.SphereGeometry(0.5, 16, 16);
    const material = new THREE.MeshStandardMaterial({
      color: 0xff5500,
      emissive: 0xff2200,
      emissiveIntensity: 2,
    });

    const mesh = new THREE.Mesh(geometry, material);
    group.add(mesh);

    // 파티클 효과 추가
    this.createParticles(group);

    return group;
  }

  private createParticles(group: THREE.Group): void {
    // 파티클 시스템 구현
    // ...
  }

  update(deltaTime: number): void {
    super.update(deltaTime);

    // 파티클 업데이트 로직
    if (this.particles && !this.finished) {
      // 파티클 애니메이션
    }
  }

  protected onReachTarget(): void {
    super.onReachTarget();

    // 파이어볼 폭발 효과
    this.createExplosion();
  }

  private createExplosion(): void {
    // 폭발 효과 구현
    // ...
  }
}
```

### 6. 발사 시스템 구현 예시

```typescript
// 표준 직선 발사 시스템
class DirectLaunchSystem extends BaseLaunchSystem {
  launch(options: ProjectileOptions): void {
    if (!this.canLaunch()) return;

    this.projectileManager.createProjectile(options);
    this.resetCooldown();
  }
}

// 다중 발사 시스템
class MultiShotLaunchSystem extends BaseLaunchSystem {
  private projectileCount: number;
  private spreadAngle: number;

  constructor(options: {
    projectileManager: ProjectileManager;
    cooldownTime?: number;
    projectileCount?: number;
    spreadAngle?: number;
  }) {
    super(options);
    this.projectileCount = options.projectileCount || 3;
    this.spreadAngle = options.spreadAngle || Math.PI / 12;
  }

  launch(options: ProjectileOptions): void {
    if (!this.canLaunch()) return;

    const baseDir = new Vector3()
      .subVectors(options.endPosition, options.startPosition)
      .normalize();

    for (let i = 0; i < this.projectileCount; i++) {
      // 각 투사체의 방향 계산
      const angle = (i - (this.projectileCount - 1) / 2) * this.spreadAngle;
      const rotatedDir = this.rotateVector(baseDir.clone(), angle);

      // 새로운 목표 위치 계산
      const targetDistance = options.startPosition.distanceTo(
        options.endPosition
      );
      const newEndPos = new Vector3()
        .copy(options.startPosition)
        .addScaledVector(rotatedDir, targetDistance);

      this.projectileManager.createProjectile({
        ...options,
        endPosition: newEndPos,
      });
    }

    this.resetCooldown();
  }

  private rotateVector(vector: Vector3, angle: number): Vector3 {
    // 2D 평면에서 벡터 회전 (Y축 기준)
    const x = vector.x * Math.cos(angle) - vector.z * Math.sin(angle);
    const z = vector.x * Math.sin(angle) + vector.z * Math.cos(angle);

    return new Vector3(x, vector.y, z).normalize();
  }
}
```

### 7. 발사 시스템 팩토리

```typescript
class LaunchSystemFactory implements ILaunchSystemFactory {
  private projectileManager: ProjectileManager;

  constructor(projectileManager: ProjectileManager) {
    this.projectileManager = projectileManager;
  }

  createLaunchSystem(
    type: string,
    params: Record<string, any> = {}
  ): ILaunchSystem {
    switch (type) {
      case "direct":
        return new DirectLaunchSystem({
          projectileManager: this.projectileManager,
          cooldownTime: params.cooldownTime,
        });

      case "multishot":
        return new MultiShotLaunchSystem({
          projectileManager: this.projectileManager,
          cooldownTime: params.cooldownTime,
          projectileCount: params.projectileCount,
          spreadAngle: params.spreadAngle,
        });

      // 더 많은 발사 시스템 타입 추가

      default:
        console.warn(
          `알 수 없는 발사 시스템 타입: ${type}, 기본 시스템으로 대체됩니다.`
        );
        return new DirectLaunchSystem({
          projectileManager: this.projectileManager,
        });
    }
  }
}
```

### 8. React 환경에서의 사용 예시 (React Three Fiber)

```typescript
// 발사 시스템 컴포넌트
const ProjectileLauncher: React.FC<{
  launchSystemType: string;
  projectileType: string;
  startPosition: Vector3;
  targetPosition: Vector3;
  speed: number;
  launchParams?: Record<string, any>;
}> = ({
  launchSystemType,
  projectileType,
  startPosition,
  targetPosition,
  speed,
  launchParams = {},
}) => {
  const { scene } = useThree();
  const projectileManagerRef = useRef<ProjectileManager | null>(null);
  const launchSystemRef = useRef<ILaunchSystem | null>(null);

  // 초기화
  useEffect(() => {
    if (!projectileManagerRef.current) {
      projectileManagerRef.current = new ProjectileManager(scene);

      // 투사체 유형 등록
      projectileManagerRef.current.registerProjectileType(
        "fireball",
        (options) => new FireBall(options)
      );
      projectileManagerRef.current.registerProjectileType(
        "bullet",
        (options) => new Bullet(options)
      );
      // 추가 프로젝타일 타입 등록...
    }

    const factory = new LaunchSystemFactory(projectileManagerRef.current);
    launchSystemRef.current = factory.createLaunchSystem(
      launchSystemType,
      launchParams
    );

    return () => {
      launchSystemRef.current?.cleanup();
    };
  }, [launchSystemType, scene]);

  // 매 프레임 업데이트
  useFrame((_, delta) => {
    projectileManagerRef.current?.update(delta);
    launchSystemRef.current?.update(delta);
  });

  // 발사 메서드
  const launchProjectile = useCallback(() => {
    if (launchSystemRef.current) {
      launchSystemRef.current.launch({
        startPosition,
        endPosition: targetPosition,
        speed,
        type: projectileType,
      });
    }
  }, [startPosition, targetPosition, speed, projectileType]);

  // 컴포넌트에 발사 메서드 노출
  useImperativeHandle(
    ref,
    () => ({
      launch: launchProjectile,
    }),
    [launchProjectile]
  );

  return null; // 시각적 요소 없음
};

// 커스텀 훅을 통한 사용 간소화
function useProjectileLauncher(options: {
  launchSystemType: string;
  projectileType: string;
  speed: number;
  launchParams?: Record<string, any>;
}) {
  const { scene } = useThree();
  const [launchSystem, setLaunchSystem] = useState<ILaunchSystem | null>(null);
  const projectileManagerRef = useRef<ProjectileManager | null>(null);

  useEffect(() => {
    if (!projectileManagerRef.current) {
      projectileManagerRef.current = new ProjectileManager(scene);

      // 투사체 유형 등록
      projectileManagerRef.current.registerProjectileType(
        "fireball",
        (options) => new FireBall(options)
      );
      projectileManagerRef.current.registerProjectileType(
        "bullet",
        (options) => new Bullet(options)
      );
      // 추가 프로젝타일 타입 등록...
    }

    const factory = new LaunchSystemFactory(projectileManagerRef.current);
    const system = factory.createLaunchSystem(
      options.launchSystemType,
      options.launchParams
    );
    setLaunchSystem(system);

    return () => {
      system.cleanup();
    };
  }, [options.launchSystemType, options.launchParams, scene]);

  useFrame((_, delta) => {
    projectileManagerRef.current?.update(delta);
    launchSystem?.update(delta);
  });

  const launch = useCallback(
    (startPosition: Vector3, endPosition: Vector3) => {
      if (launchSystem && projectileManagerRef.current) {
        launchSystem.launch({
          startPosition,
          endPosition,
          speed: options.speed,
          type: options.projectileType,
        });
      }
    },
    [launchSystem, options.speed, options.projectileType]
  );

  return { launch };
}
```

이 구조는 startPosition, endPosition, speed 파라미터를 중심으로 투사체 발사 시스템을 단순화하였습니다. AI가 코드를 쉽게 이해하고 구현할 수 있도록 핵심 컴포넌트를 명확히 분리했으며, React Three Fiber 환경에서 사용할 수 있는 형태로 설계했습니다.

---

_**User**_

AI가 해당 구조를 완벽하게 구현하기는 힘들지 않을까요? 직선으로 쏘거나 퍼지게쏘거나 하는것들을 간단하게만 어떻게 쏘는지의 로직과 이펙트와 어떻게 연계해야하는지 정도의 간단한 코드로 표현할수는 없을지 깊이 고민후 솔루션을 제안해주세요

---

_**Assistant**_

---

# 단순화된 발사 시스템 솔루션

## 1. 기본 발사 훅 (직선 발사)

```tsx
// src/hooks/useBasicLauncher.tsx
import { useState, useCallback } from "react";
import { Vector3 } from "three";
import { useFrame } from "@react-three/fiber";

// 간단한 발사 훅
export function useBasicLauncher() {
  const [projectiles, setProjectiles] = useState<any[]>([]);

  // 직선 발사 함수
  const launchProjectile = useCallback(
    (props: {
      type: string; // 발사할 이펙트 타입 (예: "fireball", "bullet" 등)
      startPosition: Vector3; // 시작 위치
      endPosition: Vector3; // 목표 위치
      speed: number; // 속도
    }) => {
      const { type, startPosition, endPosition, speed } = props;

      // 새 투사체 추가
      setProjectiles((prev) => [
        ...prev,
        {
          id: Math.random().toString(),
          type,
          startPosition: startPosition.clone(),
          endPosition: endPosition.clone(),
          position: startPosition.clone(),
          direction: new Vector3()
            .subVectors(endPosition, startPosition)
            .normalize(),
          speed,
          distance: startPosition.distanceTo(endPosition),
          traveled: 0,
          done: false,
        },
      ]);
    },
    []
  );

  // 다중 발사 (산탄형)
  const launchMultiProjectiles = useCallback(
    (props: {
      type: string;
      startPosition: Vector3;
      endPosition: Vector3;
      speed: number;
      count: number; // 발사할 투사체 수
      spread: number; // 퍼짐 각도 (라디안)
    }) => {
      const { type, startPosition, endPosition, speed, count, spread } = props;

      // 기본 방향 계산
      const baseDirection = new Vector3()
        .subVectors(endPosition, startPosition)
        .normalize();
      const distance = startPosition.distanceTo(endPosition);

      // 각 투사체마다 방향 조정하여 발사
      for (let i = 0; i < count; i++) {
        // 중앙을 기준으로 좌우로 퍼지게 각도 계산
        const angle = (i - (count - 1) / 2) * spread;

        // 방향 벡터 회전 (Y축 기준)
        const rotatedDir = new Vector3(
          baseDirection.x * Math.cos(angle) - baseDirection.z * Math.sin(angle),
          baseDirection.y,
          baseDirection.x * Math.sin(angle) + baseDirection.z * Math.cos(angle)
        ).normalize();

        // 새 목표 지점 계산
        const newTarget = new Vector3()
          .copy(startPosition)
          .addScaledVector(rotatedDir, distance);

        // 투사체 추가
        setProjectiles((prev) => [
          ...prev,
          {
            id: Math.random().toString(),
            type,
            startPosition: startPosition.clone(),
            endPosition: newTarget,
            position: startPosition.clone(),
            direction: rotatedDir,
            speed,
            distance,
            traveled: 0,
            done: false,
          },
        ]);
      }
    },
    []
  );

  // 투사체 업데이트
  useFrame((_, delta) => {
    setProjectiles((prev) => {
      // 이미 완료된 투사체 필터링
      const updated = prev.filter((p) => !p.done);

      // 각 투사체 위치 업데이트
      updated.forEach((p) => {
        // 이동 거리 계산
        const step = p.speed * delta;
        p.traveled += step;

        // 목표에 도달했는지 확인
        if (p.traveled >= p.distance) {
          p.position.copy(p.endPosition);
          p.done = true;
        } else {
          // 위치 업데이트
          p.position
            .copy(p.startPosition)
            .addScaledVector(p.direction, p.traveled);
        }
      });

      return updated;
    });
  });

  return {
    projectiles,
    launchProjectile, // 단일 발사
    launchMultiProjectiles, // 다중 발사
  };
}
```

## 2. 발사 시스템과 이펙트 연결 컴포넌트

```tsx
// src/components/ProjectileSystem.tsx
import React from "react";
import { useBasicLauncher } from "../hooks/useBasicLauncher";

// 이펙트 컴포넌트들 임포트
import { FireBall } from "./effects/FireBall";
import { Bullet } from "./effects/Bullet";
import { Laser } from "./effects/Laser";

// 프로젝타일 시스템 컴포넌트
export const ProjectileSystem = React.forwardRef((props, ref) => {
  const { projectiles, launchProjectile, launchMultiProjectiles } =
    useBasicLauncher();

  // 외부에서 사용할 수 있도록 ref로 메서드 노출
  React.useImperativeHandle(ref, () => ({
    launchSingle: launchProjectile,
    launchMulti: launchMultiProjectiles,
  }));

  return (
    <>
      {projectiles.map((projectile) => {
        // 투사체 타입에 따라 적절한 이펙트 컴포넌트 렌더링
        switch (projectile.type) {
          case "fireball":
            return (
              <FireBall
                key={projectile.id}
                position={projectile.position}
                direction={projectile.direction}
                done={projectile.done}
              />
            );

          case "bullet":
            return (
              <Bullet
                key={projectile.id}
                position={projectile.position}
                direction={projectile.direction}
                done={projectile.done}
              />
            );

          case "laser":
            return (
              <Laser
                key={projectile.id}
                position={projectile.position}
                direction={projectile.direction}
                done={projectile.done}
              />
            );

          default:
            return null;
        }
      })}
    </>
  );
});
```

## 3. 사용 예시 - 게임 컴포넌트에서

```tsx
// src/components/Game.tsx
import React, { useRef } from "react";
import { Canvas } from "@react-three/fiber";
import { OrbitControls, PerspectiveCamera } from "@react-three/drei";
import { Vector3 } from "three";
import { ProjectileSystem } from "./ProjectileSystem";

const Game = () => {
  // 발사 시스템 참조
  const projectileSystemRef = useRef();

  // 마우스 클릭 시 발사 처리
  const handleShoot = (event) => {
    if (!projectileSystemRef.current) return;

    // 시작 위치 (캐릭터 또는 무기 위치)
    const startPos = new Vector3(0, 1, 0);

    // 목표 위치 (예: 마우스 클릭 위치 또는 방향에 따른 거리)
    const targetPos = new Vector3(Math.random() * 10 - 5, 1, -10);

    // 일반 발사 (단일)
    if (event.button === 0) {
      // 좌클릭
      projectileSystemRef.current.launchSingle({
        type: "fireball",
        startPosition: startPos,
        endPosition: targetPos,
        speed: 15,
      });
    }
    // 다중 발사 (산탄형)
    else if (event.button === 2) {
      // 우클릭
      projectileSystemRef.current.launchMulti({
        type: "bullet",
        startPosition: startPos,
        endPosition: targetPos,
        speed: 20,
        count: 5,
        spread: Math.PI / 12, // 15도
      });
    }
  };

  return (
    <div
      style={{ width: "100vw", height: "100vh" }}
      onMouseDown={handleShoot}
      onContextMenu={(e) => e.preventDefault()}
    >
      <Canvas>
        <PerspectiveCamera makeDefault position={[0, 5, 10]} />
        <OrbitControls />

        <ambientLight intensity={0.5} />
        <directionalLight position={[10, 10, 5]} intensity={1} />

        {/* 바닥 메시 */}
        <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]}>
          <planeGeometry args={[20, 20]} />
          <meshStandardMaterial color="#444" />
        </mesh>

        {/* 투사체 시스템 */}
        <ProjectileSystem ref={projectileSystemRef} />
      </Canvas>
    </div>
  );
};

export default Game;
```

## 4. 이펙트 컴포넌트 예시 (Fireball)

```tsx
// src/components/effects/FireBall.tsx
import React, { useRef, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { Vector3 } from "three";

export const FireBall = ({ position, direction, done }) => {
  const groupRef = useRef();

  // 발사체가 목표에 도달했을 때 폭발 효과
  useEffect(() => {
    if (done && groupRef.current) {
      // 폭발 효과 생성 또는 애니메이션 시작
      console.log("폭발 효과 발생!");

      // 파티클 시스템 활성화, 크기 확대 등의 효과
      // ...
    }
  }, [done]);

  // 추가 애니메이션 효과
  useFrame((_, delta) => {
    if (groupRef.current && !done) {
      // 투사체 자체 회전 애니메이션
      groupRef.current.rotation.x += delta * 5;
      groupRef.current.rotation.z += delta * 3;
    }
  });

  return (
    <group ref={groupRef} position={position}>
      {/* 파이어볼 메시 */}
      <mesh>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          color="#ff5500"
          emissive="#ff2200"
          emissiveIntensity={2}
        />
      </mesh>

      {/* 불꽃 효과 (간단한 예시) */}
      <pointLight color="#ff5500" intensity={5} distance={3} />

      {/* 트레일 효과는 여기에 추가 */}
    </group>
  );
};
```

## 키포인트

1. **단순한 상태 관리**: useState와 useRef를 사용하여 복잡한 클래스 구조 없이 투사체 관리
2. **분리된 관심사**: 투사체 로직(useBasicLauncher)과 렌더링(ProjectileSystem) 분리
3. **유연한 연결**: 이펙트 컴포넌트들과 쉽게 연결 가능한 구조
4. **직관적인 API**: 단일 발사와 다중 발사 함수 제공
5. **최소한의 계산**: 시작점, 끝점, 속도만으로 직선 이동 구현

이 솔루션은 복잡한 클래스 구조나 디자인 패턴 없이 React 훅과 컴포넌트만으로 구현되어 있어 AI가 이해하고 구현하기 쉬우며, 기존 이펙트 컴포넌트들과 손쉽게 통합할 수 있습니다.

---

_**User**_

직선 발사, 다중 발사는 키보드로 쓰던 마우스로 쓰던 재활용 가능한 구조일까요?

---

_**Assistant**_

---

네, 현재 설계된 구조는 키보드나 마우스 입력 방식과 독립적으로 재활용 가능합니다. 이 구조의 핵심 장점은 다음과 같습니다:

1. **입력과 발사 로직의 분리**:

   - `useBasicLauncher` 훅은 투사체 관리와 발사 로직만 담당
   - 실제 입력 처리(키보드/마우스)는 이 시스템을 사용하는 상위 컴포넌트에서 결정

2. **위치 기반 인터페이스**:

   - 발사 함수들은 단순히 `startPosition`과 `endPosition` 값만 필요
   - 이 값들은 어떤 입력 방식에서든 계산 가능

3. **재활용 예시**:

   **키보드 입력일 경우:**

   ```tsx
   // 키보드 방향키에 따른 발사 처리
   useEffect(() => {
     const handleKeyDown = (e) => {
       if (e.code === "Space" && projectileSystemRef.current) {
         const playerPos = new Vector3(0, 1, 0);
         let targetPos;

         // 방향키에 따라 타겟 위치 결정
         if (keysPressed["ArrowUp"]) {
           targetPos = new Vector3(0, 1, -10);
         } else if (keysPressed["ArrowRight"]) {
           targetPos = new Vector3(10, 1, 0);
         } // 다른 방향들...

         projectileSystemRef.current.launchSingle({
           type: "fireball",
           startPosition: playerPos,
           endPosition: targetPos,
           speed: 15,
         });
       }
     };

     window.addEventListener("keydown", handleKeyDown);
     return () => window.removeEventListener("keydown", handleKeyDown);
   }, [keysPressed]);
   ```

   **마우스 입력일 경우:**

   ```tsx
   // 마우스 클릭 위치로 발사
   const handleMouseClick = (e) => {
     if (projectileSystemRef.current) {
       const playerPos = new Vector3(0, 1, 0);

       // 마우스 클릭 위치를 3D 공간으로 변환
       const mousePos = getMousePositionIn3D(e);

       projectileSystemRef.current.launchSingle({
         type: "fireball",
         startPosition: playerPos,
         endPosition: mousePos,
         speed: 15,
       });
     }
   };
   ```

동일한 발사 시스템을 사용하면서 입력 처리 부분만 교체하면 됩니다. 이는 이 설계가 입력 방식과 발사 로직을 명확히 분리했기 때문에 가능합니다.

---

_**User**_

만약 사용자가 요청한 내용이 "마우스로 총 쏘게해줘" 이거나 "키보드로 총 쏘게해줘" 라고 했을때 vectorDB 에서 코드를 찾아 올바르게 구현이 가능하도록 하려면 어떤 형태로 코드를 vectorDB에 DB화 하면 좋을까요?

---

_**Assistant**_

---

VectorDB에 발사 시스템 코드를 효과적으로 저장하기 위한 최적의 방법은 다음과 같습니다:

## 1. 모듈식 코드 청크 구조화

```typescript
// MODULE: [발사-시스템-코어]
// KEYWORDS: 발사, 투사체, 총, 미사일, 화살, 발사체
// DESCRIPTION: 기본 발사 시스템 로직 (입력 방식 독립적)
export function useBasicLauncher() {
  // 발사 로직 구현...
  return { projectiles, launchProjectile, launchMultiProjectiles };
}
```

```typescript
// MODULE: [마우스-입력-발사]
// KEYWORDS: 마우스, 클릭, 총, 발사, 조준, 에임
// DEPENDENCIES: [발사-시스템-코어]
// DESCRIPTION: 마우스 클릭으로 총을 발사하는 구현
export function useMouseShooter() {
  const { launchProjectile } = useBasicLauncher();

  // 마우스 입력 처리 및 발사 로직
  const handleMouseDown = useCallback((event) => {
    // 마우스 위치 변환 및 발사 로직
    // ...
  }, []);

  return { handleMouseDown };
}
```

```typescript
// MODULE: [키보드-입력-발사]
// KEYWORDS: 키보드, 스페이스바, 화살표, 총, 발사, WASD
// DEPENDENCIES: [발사-시스템-코어]
// DESCRIPTION: 키보드 입력으로 총을 발사하는 구현
export function useKeyboardShooter() {
  const { launchProjectile } = useBasicLauncher();

  // 키보드 입력 처리 및 발사 로직
  // ...

  return { handleKeyDown };
}
```

## 2. 통합 사용 예제

```typescript
// MODULE: [마우스-총-발사-예제]
// KEYWORDS: 마우스, 클릭, 총, 발사, 완성, 예제
// DEPENDENCIES: [발사-시스템-코어, 마우스-입력-발사]
// DESCRIPTION: 마우스로 총을 발사하는 완전한 구현 예제
export function MouseShooterExample() {
  const projectileSystemRef = useRef();
  const { handleMouseDown } = useMouseShooter();

  return (
    <div onMouseDown={handleMouseDown}>
      <Canvas>
        {/* 3D 환경 설정 */}
        <ProjectileSystem ref={projectileSystemRef} />
      </Canvas>
    </div>
  );
}
```

## 3. 메타데이터 구조 및 태그 시스템

각 코드 모듈에 포함해야 할 메타데이터:

1. **모듈 ID**: 고유 식별자
2. **키워드**: 검색 가능한 주요 단어들 (입력 방식, 무기 유형, 기능)
3. **의존성**: 연관된 다른 모듈들
4. **설명**: 모듈 기능에 대한 간결한 설명
5. **코드 타입**:
   - `CORE` (핵심 로직)
   - `INPUT` (입력 처리)
   - `INTEGRATION` (통합 예제)
   - `EFFECT` (시각 효과)
6. **사용 맥락**:
   - `KEYBOARD` (키보드 입력)
   - `MOUSE` (마우스 입력)
   - `TOUCH` (터치 입력)
   - `ANY` (입력 독립적)

## 4. VectorDB 저장 JSON 예시

```json
{
  "id": "mouse-shooter-implementation",
  "title": "마우스 기반 총 발사 구현",
  "codeType": "INTEGRATION",
  "inputContext": "MOUSE",
  "projectileType": ["bullet", "laser", "generic"],
  "keywords": ["마우스", "클릭", "총", "발사", "조준", "슈팅", "3D"],
  "dependencies": ["basic-launcher-core", "mouse-input-handler"],
  "description": "마우스 클릭으로 3D 공간에 투사체를 발사하는 완전한 구현",
  "code": "// 실제 코드 내용...",
  "usageExample": "// 사용 예시 코드...",
  "requiredImports": ["@react-three/fiber", "three", "react"],
  "difficulty": "intermediate"
}
```

## 5. 검색 효율화를 위한 추가 전략

1. **계층적 태그 시스템**:

   - 상위 카테고리: `발사-시스템`, `입력-처리`, `효과`
   - 하위 카테고리: `직선-발사`, `다중-발사`, `마우스-입력`, `키보드-입력`

2. **코드 조각의 분리**:

   - 완전한 구현 모듈
   - 핵심 로직만 포함된 최소 모듈
   - 커스터마이징 옵션이 포함된 확장 모듈

3. **조합 가능한 청크**:
   - 입력 처리 모듈 (마우스/키보드)
   - 발사 로직 모듈 (직선/다중)
   - 시각 효과 모듈 (총구 화염/탄도 효과)
   - 통합 컴포넌트 (완전한 예제)

이렇게 구조화하면 VectorDB는 "마우스로 총 쏘게해줘"라는 요청에서 "마우스", "총", "발사" 키워드를 추출하여 관련 모듈들을 정확히 검색할 수 있고, AI는 이러한 모듈들을 조합하여 요구사항에 맞는 구현을 제공할 수 있습니다.

---

_**User**_

직선으로 총을쏘는 로직을 vectordb 화 한다고했을때 키보드로 직선으로 쏘는로직, 마우스로 직선으로 쏘는 로직 둘다 db화 하라는 얘기일까요?

---

_**Assistant**_

---

네, 가장 효과적인 접근법은 다음과 같이 모듈을 분리하여 DB화하는 것입니다:

### 1. 핵심 직선 발사 로직 (입력 독립적)

```typescript
// MODULE_ID: direct-projectile-core
// KEYWORDS: 직선, 발사, 투사체, 코어, 총, 기본
// CONTEXT: ANY
// 입력 방식과 독립적인 순수 직선 발사 로직
```

### 2. 키보드 입력 처리 모듈

```typescript
// MODULE_ID: keyboard-input-handler
// KEYWORDS: 키보드, 방향키, WASD, 스페이스바, 입력, 총
// CONTEXT: KEYBOARD
// 키보드 입력을 감지하고 발사 방향 계산
```

### 3. 마우스 입력 처리 모듈

```typescript
// MODULE_ID: mouse-input-handler
// KEYWORDS: 마우스, 클릭, 포인터, 조준, 에임, 총
// CONTEXT: MOUSE
// 마우스 입력을 감지하고 발사 방향 계산
```

### 4. 통합 예제 모듈 (키보드)

```typescript
// MODULE_ID: keyboard-shooter-example
// KEYWORDS: 키보드, 방향키, 총, 직선, 발사, 예제
// DEPENDENCIES: direct-projectile-core, keyboard-input-handler
// CONTEXT: KEYBOARD
// 키보드로 직선 발사하는 완전한 예제
```

### 5. 통합 예제 모듈 (마우스)

```typescript
// MODULE_ID: mouse-shooter-example
// KEYWORDS: 마우스, 클릭, 총, 직선, 발사, 예제
// DEPENDENCIES: direct-projectile-core, mouse-input-handler
// CONTEXT: MOUSE
// 마우스로 직선 발사하는 완전한 예제
```

이 구조의 장점:

1. **재사용성**: 핵심 발사 로직은 모든 입력 방식에서 재사용
2. **정확한 검색**: 사용자가 "마우스로 총 쏘게" 요청 시 정확한 모듈 검색 가능
3. **유연성**: AI가 핵심 로직과 입력 처리를 적절히 조합 가능
4. **명확한 분리**: 각 모듈이 한 가지 책임만 담당하여 코드 이해 용이

따라서 "직선으로 총을 쏘는 로직"은 핵심 로직(1)과 입력별 통합 예제(4, 5) 모두 DB화하는 것이 최적입니다.

---

_**User**_

제가 더 잘 이해할수있게 좀 더 구체적인 예시를 들어주세요

---

_**Assistant**_

---

# VectorDB 구체적 예시: 직선 발사 시스템

아래는 VectorDB에 저장될 각 모듈의 실제 예시 코드와 메타데이터입니다.

## 모듈 1: 핵심 직선 발사 로직

```json
{
  "id": "directional-shooter-core",
  "title": "직선 발사 핵심 로직",
  "keywords": ["직선", "발사", "총", "핵심", "투사체", "코어", "로직"],
  "context": "ANY",
  "description": "입력 방식과 독립적인 직선 발사 기본 로직",
  "code": `
// directionalShooterCore.ts
import { useState } from 'react';
import { Vector3 } from 'three';
import { useFrame } from '@react-three/fiber';

export function useDirectionalShooter() {
  const [projectiles, setProjectiles] = useState([]);
  
  // 직선 발사 함수
  const fireProjectile = (startPos, endPos, speed = 15, type = 'bullet') => {
    const direction = new Vector3().subVectors(endPos, startPos).normalize();
    const distance = startPos.distanceTo(endPos);
    
    setProjectiles(prev => [...prev, {
      id: Date.now().toString(),
      position: startPos.clone(),
      direction,
      distance,
      traveled: 0,
      speed,
      type,
      done: false
    }]);
  };
  
  // 프레임마다 투사체 위치 업데이트
  useFrame((_, delta) => {
    setProjectiles(prev => 
      prev.filter(p => !p.done).map(p => {
        const step = p.speed * delta;
        p.traveled += step;
        
        if (p.traveled >= p.distance) {
          p.done = true;
          // 여기에 충돌/폭발 효과 트리거 가능
        } else {
          p.position.addScaledVector(p.direction, step);
        }
        
        return p;
      })
    );
  });
  
  return { projectiles, fireProjectile };
}`
}
```

## 모듈 2: 키보드 입력 처리

```json
{
  "id": "keyboard-shooter-input",
  "title": "키보드 총 발사 입력 처리",
  "keywords": ["키보드", "방향키", "WASD", "스페이스바", "총", "발사", "입력"],
  "context": "KEYBOARD",
  "dependencies": ["directional-shooter-core"],
  "description": "키보드로 직선 발사 방향을 제어하는 모듈",
  "code": `
// keyboardShooterInput.ts
import { useEffect, useState, useCallback } from 'react';
import { Vector3 } from 'three';
import { useDirectionalShooter } from './directionalShooterCore';

export function useKeyboardShooter(playerPosition = new Vector3(0, 1, 0)) {
  const { projectiles, fireProjectile } = useDirectionalShooter();
  const [keysPressed, setKeysPressed] = useState({});
  
  // 키 입력 감지
  useEffect(() => {
    const handleKeyDown = (e) => {
      setKeysPressed(prev => ({ ...prev, [e.code]: true }));
    };
    
    const handleKeyUp = (e) => {
      setKeysPressed(prev => ({ ...prev, [e.code]: false }));
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);
  
  // 스페이스바로 발사
  useEffect(() => {
    if (keysPressed['Space']) {
      // 현재 방향 계산
      const direction = new Vector3(0, 0, -1); // 기본 방향: 앞쪽
      
      // 방향키나 WASD에 따라 방향 조정
      if (keysPressed['KeyW'] || keysPressed['ArrowUp']) direction.z = -1;
      if (keysPressed['KeyS'] || keysPressed['ArrowDown']) direction.z = 1;
      if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) direction.x = -1;
      if (keysPressed['KeyD'] || keysPressed['ArrowRight']) direction.x = 1;
      
      direction.normalize();
      
      // 목표 위치 계산 (방향 * 거리)
      const targetPos = new Vector3().copy(playerPosition).addScaledVector(direction, 30);
      
      // 발사
      fireProjectile(playerPosition, targetPos);
    }
  }, [keysPressed, playerPosition, fireProjectile]);
  
  return { projectiles };
}`
}
```

## 모듈 3: 마우스 입력 처리

```json
{
  "id": "mouse-shooter-input",
  "title": "마우스 총 발사 입력 처리",
  "keywords": [
    "마우스",
    "클릭",
    "포인터",
    "조준",
    "에임",
    "총",
    "발사",
    "입력"
  ],
  "context": "MOUSE",
  "dependencies": ["directional-shooter-core"],
  "description": "마우스로 직선 발사 방향을 제어하는 모듈",
  "code": `
// mouseShooterInput.ts
import { useCallback } from 'react';
import { Vector3, Raycaster } from 'three';
import { useThree } from '@react-three/fiber';
import { useDirectionalShooter } from './directionalShooterCore';

export function useMouseShooter(playerPosition = new Vector3(0, 1, 0)) {
  const { projectiles, fireProjectile } = useDirectionalShooter();
  const { camera, scene } = useThree();
  
  // 마우스 클릭 위치로 발사
  const handleShoot = useCallback((event) => {
    // 마우스 위치를 정규화 (-1 ~ 1)
    const mouse = {
      x: (event.clientX / window.innerWidth) * 2 - 1,
      y: -(event.clientY / window.innerHeight) * 2 + 1
    };
    
    // 레이캐스팅으로 3D 공간의 타겟 위치 계산
    const raycaster = new Raycaster();
    raycaster.setFromCamera(mouse, camera);
    
    // 바닥이나 오브젝트와의 교차점 찾기
    const intersects = raycaster.intersectObjects(scene.children, true);
    
    if (intersects.length > 0) {
      // 첫 번째 교차점을 타겟으로 사용
      const targetPosition = intersects[0].point;
      
      // 발사
      fireProjectile(playerPosition, targetPosition);
    } else {
      // 교차점이 없으면 레이 방향으로 멀리 발사
      const farPosition = new Vector3()
        .copy(raycaster.ray.direction)
        .multiplyScalar(100)
        .add(camera.position);
        
      fireProjectile(playerPosition, farPosition);
    }
  }, [camera, scene, playerPosition, fireProjectile]);
  
  return { projectiles, handleShoot };
}`
}
```

## 모듈 4: 렌더링 컴포넌트

```json
{
  "id": "projectile-renderer",
  "title": "투사체 렌더링 컴포넌트",
  "keywords": ["렌더링", "투사체", "총알", "시각화", "이펙트"],
  "context": "ANY",
  "description": "발사된 투사체를 화면에 렌더링하는 컴포넌트",
  "code": `
// ProjectileRenderer.jsx
import React from 'react';

export const ProjectileRenderer = ({ projectiles }) => {
  return (
    <>
      {projectiles.map(projectile => (
        <mesh key={projectile.id} position={projectile.position}>
          {/* 총알 타입에 따라 다른 형태 렌더링 */}
          {projectile.type === 'bullet' && (
            <>
              <sphereGeometry args={[0.2, 8, 8]} />
              <meshStandardMaterial color="yellow" emissive="orange" />
            </>
          )}
          
          {projectile.type === 'laser' && (
            <>
              <cylinderGeometry args={[0.05, 0.05, 1, 8]} />
              <meshStandardMaterial color="red" emissive="red" emissiveIntensity={2} />
            </>
          )}
          
          {/* 기본 총알 */}
          {!['bullet', 'laser'].includes(projectile.type) && (
            <>
              <sphereGeometry args={[0.15, 8, 8]} />
              <meshStandardMaterial color="white" />
            </>
          )}
        </mesh>
      ))}
    </>
  );
};`
}
```

## 모듈 5: 키보드 발사 완성 예제

```json
{
  "id": "keyboard-shooter-example",
  "title": "키보드로 직선 총 발사 완전 예제",
  "keywords": ["키보드", "총", "직선", "발사", "완성", "예제", "게임"],
  "context": "KEYBOARD",
  "dependencies": [
    "directional-shooter-core",
    "keyboard-shooter-input",
    "projectile-renderer"
  ],
  "description": "키보드로 직선 총을 발사하는 완전한 게임 예제",
  "code": `
// KeyboardShooterGame.jsx
import React, { useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera } from '@react-three/drei';
import { Vector3 } from 'three';
import { useKeyboardShooter } from './keyboardShooterInput';
import { ProjectileRenderer } from './ProjectileRenderer';

export const KeyboardShooterGame = () => {
  // 플레이어 위치
  const playerPosition = new Vector3(0, 1, 0);
  
  // 키보드 발사 시스템 사용
  const { projectiles } = useKeyboardShooter(playerPosition);
  
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <div style={{ position: 'absolute', bottom: 20, left: 20, color: 'white' }}>
        방향키로 방향 지정, 스페이스바로 발사
      </div>
      
      <Canvas>
        <PerspectiveCamera makeDefault position={[0, 5, 10]} />
        <OrbitControls />
        
        <ambientLight intensity={0.5} />
        <directionalLight position={[10, 10, 5]} intensity={1} />
        
        {/* 바닥 */}
        <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]}>
          <planeGeometry args={[30, 30]} />
          <meshStandardMaterial color="darkgreen" />
        </mesh>
        
        {/* 플레이어 */}
        <mesh position={playerPosition}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color="blue" />
        </mesh>
        
        {/* 투사체 렌더링 */}
        <ProjectileRenderer projectiles={projectiles} />
      </Canvas>
    </div>
  );
};`
}
```

## 모듈 6: 마우스 발사 완성 예제

```json
{
  "id": "mouse-shooter-example",
  "title": "마우스로 직선 총 발사 완전 예제",
  "keywords": ["마우스", "클릭", "총", "직선", "발사", "완성", "예제", "게임"],
  "context": "MOUSE",
  "dependencies": [
    "directional-shooter-core",
    "mouse-shooter-input",
    "projectile-renderer"
  ],
  "description": "마우스로 직선 총을 발사하는 완전한 게임 예제",
  "code": `
// MouseShooterGame.jsx
import React from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera } from '@react-three/drei';
import { Vector3 } from 'three';
import { useMouseShooter } from './mouseShooterInput';
import { ProjectileRenderer } from './ProjectileRenderer';

export const MouseShooterGame = () => {
  // 플레이어 위치
  const playerPosition = new Vector3(0, 1, 0);
  
  // 마우스 발사 시스템 사용
  const { projectiles, handleShoot } = useMouseShooter(playerPosition);
  
  return (
    <div 
      style={{ width: '100vw', height: '100vh' }}
      onClick={handleShoot}
    >
      <div style={{ position: 'absolute', bottom: 20, left: 20, color: 'white' }}>
        마우스 클릭으로 발사
      </div>
      
      <Canvas>
        <PerspectiveCamera makeDefault position={[0, 5, 10]} />
        <OrbitControls />
        
        <ambientLight intensity={0.5} />
        <directionalLight position={[10, 10, 5]} intensity={1} />
        
        {/* 바닥 */}
        <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]} name="ground">
          <planeGeometry args={[30, 30]} />
          <meshStandardMaterial color="darkgreen" />
        </mesh>
        
        {/* 플레이어 */}
        <mesh position={playerPosition}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color="blue" />
        </mesh>
        
        {/* 투사체 렌더링 */}
        <ProjectileRenderer projectiles={projectiles} />
      </Canvas>
    </div>
  );
};`
}
```

## VectorDB 활용 시나리오

사용자 요청: "마우스로 총 쏘게 해줘"

1. **키워드 추출**: "마우스", "총", "발사"

2. **VectorDB 검색**:

   - `mouse-shooter-input` (높은 관련성)
   - `mouse-shooter-example` (높은 관련성)
   - `directional-shooter-core` (중간 관련성)
   - `projectile-renderer` (중간 관련성)

3. **AI 코드 조합**:

   - `directional-shooter-core`의 핵심 발사 로직 활용
   - `mouse-shooter-input`의 마우스 입력 처리 통합
   - `projectile-renderer`로 투사체 시각화
   - 최종적으로 `mouse-shooter-example`를 기반으로 완성된 예제 제공

4. **맞춤형 조정**:
   - 사용자의 기존 코드베이스 구조에 맞게 수정
   - 필요한 임포트 추가 및 경로 조정
   - 불필요한 코드 제거

이런 방식으로 사용자의 "마우스로 총 쏘게 해줘" 요청에 적합한 직선 발사 시스템을 제공할 수 있습니다. 마찬가지로 "키보드로 총 쏘게 해줘" 요청에는 키보드 관련 모듈을 활용하여 구현할 수 있습니다.

---

_**User**_

vectorDB 에서 검색된 4가지를 AI가 모두 읽을거라는 보장이 없지 않나요?

---

_**Assistant**_

---

정확한 지적입니다. VectorDB에서 검색된 여러 모듈을 AI가 모두 적절히 읽고 통합한다는 보장이 없습니다. 이 문제를 해결하기 위한 몇 가지 방안이 있습니다:

### 1. 의존성 그래프 메타데이터 추가

```json
{
  "id": "mouse-shooter-complete",
  "title": "마우스 총 발사 통합 패키지",
  "keywords": ["마우스", "총", "발사", "완성"],
  "context": "MOUSE",
  "dependencies_graph": {
    "root": "mouse-shooter-example",
    "required_modules": [
      "directional-shooter-core",
      "mouse-shooter-input",
      "projectile-renderer"
    ],
    "optional_modules": ["effects-manager"]
  },
  "implementation_order": [
    "directional-shooter-core",
    "mouse-shooter-input",
    "projectile-renderer",
    "mouse-shooter-example"
  ]
}
```

### 2. "올인원" 솔루션 제공

각 사용 사례에 대해 모든 필요한 코드를 포함하는 단일 모듈을 생성:

```typescript
// MODULE_ID: mouse-shooter-all-in-one
// KEYWORDS: 마우스, 총, 직선, 발사, 완전한, 독립적
// DESCRIPTION: 마우스로 총을 발사하는 완전한 독립 솔루션
// CONTEXT: MOUSE

// 1. 핵심 발사 로직
function useDirectionalShooter() {
  /* 전체 구현 */
}

// 2. 마우스 입력 처리
function useMouseInput() {
  /* 전체 구현 */
}

// 3. 렌더링 컴포넌트
function ProjectileRenderer() {
  /* 전체 구현 */
}

// 4. 완성된 사용 예제
export function MouseShooterGame() {
  // 모든 로직을 포함한 완전한 구현
}
```

### 3. 계층적 검색 시스템 구현

1. **첫 단계**: "마우스로 총 쏘게 해줘" → "mouse-shooter-example" 검색
2. **두 번째 단계**: AI가 코드를 분석하여 의존성 파악
3. **세 번째 단계**: 발견된 의존성에 대해 추가 검색 수행

### 4. 코드 청크 "최소 완전 단위" 설계

각 코드 모듈이 독립적으로 작동할 수 있는 최소한의 자급자족 단위가 되도록 설계:

```typescript
// MODULE_ID: mouse-shooter-minimal
// KEYWORDS: 마우스, 총, 직선, 발사, 최소
// CONTEXT: MOUSE

// 이 단일 모듈만으로 기본 기능 구현 가능
export function useMouseShooter() {
  // 핵심 발사 로직 (내장)
  const [projectiles, setProjectiles] = useState([]);

  // 기본 발사 함수 (내장)
  const fireProjectile = (start, end) => {
    /* 구현 */
  };

  // 마우스 핸들러 (내장)
  const handleClick = (e) => {
    /* 구현 */
  };

  // 렌더링 컴포넌트 (내장)
  const ProjectileView = () => {
    /* 구현 */
  };

  return { handleClick, ProjectileView };
}
```

### 최적의 솔루션

실용적으로는 다음 접근법이 가장 효과적일 것입니다:

1. **계층적 모듈**: 독립 실행 가능한 작은 모듈부터 완전한 솔루션까지 계층화
2. **명시적 관계**: 의존성과 구현 순서를 메타데이터에 명확히 표시
3. **자급자족 옵션**: "올인원" 솔루션을 제공하되, 필요에 따라 모듈화도 지원

이렇게 하면 AI가 VectorDB 검색 결과의 일부만 사용하더라도 사용자의 요청을 충족할 가능성이 크게 향상됩니다.

---

_**User**_

AI가 보고 완벽하게 구현할수있는 키보드 입력처리에 대한 코드스니펫을 만들어주세요

---

_**Assistant**_

---

```typescript
// useKeyboardShooter.ts - 키보드 입력으로 직선 발사 제어하는 간단한 훅
import { useState, useEffect, useCallback } from "react";
import { Vector3 } from "three";
import { useFrame } from "@react-three/fiber";

type Projectile = {
  id: string;
  position: Vector3;
  direction: Vector3;
  speed: number;
  traveled: number;
  maxDistance: number;
  done: boolean;
};

export function useKeyboardShooter(options: {
  playerPosition?: Vector3;
  projectileSpeed?: number;
  projectileDistance?: number;
  fireKey?: string;
}) {
  // 기본값 설정
  const {
    playerPosition = new Vector3(0, 1, 0),
    projectileSpeed = 15,
    projectileDistance = 50,
    fireKey = "Space",
  } = options;

  // 활성화된 프로젝타일 관리
  const [projectiles, setProjectiles] = useState<Projectile[]>([]);

  // 현재 눌린 키 추적
  const [keys, setKeys] = useState<Record<string, boolean>>({});

  // 키 입력 이벤트 처리
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      setKeys((prev) => ({ ...prev, [e.code]: true }));
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      setKeys((prev) => ({ ...prev, [e.code]: false }));

      // 발사 키가 떼어졌을 때 발사
      if (e.code === fireKey) {
        fireProjectile();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [fireKey]);

  // 현재 방향 계산 (방향키 또는 WASD)
  const getCurrentDirection = useCallback(() => {
    const direction = new Vector3(0, 0, 0);

    // 앞/뒤 (Z축)
    if (keys["ArrowUp"] || keys["KeyW"]) direction.z -= 1;
    if (keys["ArrowDown"] || keys["KeyS"]) direction.z += 1;

    // 좌/우 (X축)
    if (keys["ArrowLeft"] || keys["KeyA"]) direction.x -= 1;
    if (keys["ArrowRight"] || keys["KeyD"]) direction.x += 1;

    // 방향 정규화 (길이를 1로)
    return direction.length() > 0
      ? direction.normalize()
      : new Vector3(0, 0, -1);
  }, [keys]);

  // 프로젝타일 발사 함수
  const fireProjectile = useCallback(() => {
    const direction = getCurrentDirection();
    const targetPosition = new Vector3()
      .copy(playerPosition)
      .addScaledVector(direction, projectileDistance);

    setProjectiles((prev) => [
      ...prev,
      {
        id: Math.random().toString(),
        position: playerPosition.clone(),
        direction,
        speed: projectileSpeed,
        traveled: 0,
        maxDistance: projectileDistance,
        done: false,
      },
    ]);
  }, [
    playerPosition,
    projectileSpeed,
    projectileDistance,
    getCurrentDirection,
  ]);

  // 프로젝타일 업데이트
  useFrame((_, delta) => {
    setProjectiles((prev) =>
      prev
        .filter((p) => !p.done)
        .map((p) => {
          // 새 객체를 생성하여 불변성 유지
          const updated = { ...p };
          const step = updated.speed * delta;
          updated.traveled += step;

          if (updated.traveled >= updated.maxDistance) {
            // 최대 거리 도달
            updated.done = true;
          } else {
            // 위치 업데이트
            updated.position.addScaledVector(updated.direction, step);
          }

          return updated;
        })
    );
  });

  return {
    projectiles, // 활성화된 프로젝타일 배열
    fireProjectile, // 수동으로 발사 트리거
    isKeyPressed: (code: string) => !!keys[code], // 특정 키가 눌렸는지 확인
  };
}
```

사용 예시:

```tsx
// 컴포넌트에서 사용 방법
function ShooterGame() {
  const { projectiles } = useKeyboardShooter({
    playerPosition: new Vector3(0, 1, 0),
    projectileSpeed: 20,
    fireKey: "Space",
  });

  return (
    <>
      {/* 프로젝타일 렌더링 */}
      {projectiles.map((p) => (
        <mesh key={p.id} position={p.position}>
          <sphereGeometry args={[0.2, 8, 8]} />
          <meshStandardMaterial color="yellow" />
        </mesh>
      ))}
    </>
  );
}
```

---

_**User**_

useKeyboardShooter.ts 에서 fireProjectile을 제공하는건 깔끔한 구조가 아닌것같습니다. 현재 codebase 를 기반으로 @controls.ts 키보드입력은 어떻게 받고있으며 @EffectContainer.tsx 이펙트는 어떻게 관리되고 그려지는지 면밀히 살펴보고 숙지하여 코드스니펫을 만들어주세요.

---

_**Assistant**_

---

```typescript
// useKeyboardProjectileControl.ts - 키보드 입력을 통한 투사체 발사 제어
import { useCallback, useEffect } from "react";
import { Vector3 } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { useEffectStore } from "../components/store/effectStore";
import { EffectType } from "../types/effect";
import { useGameServer } from "@agent8/gameserver";

export type ProjectileControlOptions = {
  startPosition?: Vector3 | (() => Vector3);
  targetPosition?: Vector3 | (() => Vector3);
  projectileSpeed?: number;
  projectileType?: EffectType;
  fireAction?: string;
  directionActions?: {
    forward: string;
    backward: string;
    leftward: string;
    rightward: string;
  };
};

/**
 * 키보드 입력을 통해 투사체 발사를 제어하는 훅
 */
export function useKeyboardProjectileControl(
  options: ProjectileControlOptions = {}
) {
  const {
    projectileType = EffectType.BULLET,
    projectileSpeed = 15,
    fireAction = "action1",
    directionActions = {
      forward: "forward",
      backward: "backward",
      leftward: "leftward",
      rightward: "rightward",
    },
  } = options;

  // 이펙트 스토어에서 이펙트 추가 액션 가져오기
  const addEffect = useEffectStore((state) => state.addEffect);
  const { server, account } = useGameServer();

  // 키보드 입력 상태 구독
  const [subscribeKeys, getKeys] = useKeyboardControls();

  // 발사 방향 계산
  const calculateDirection = useCallback(() => {
    const keys = getKeys();
    const direction = new Vector3(0, 0, 0);

    if (keys[directionActions.forward]) direction.z -= 1;
    if (keys[directionActions.backward]) direction.z += 1;
    if (keys[directionActions.leftward]) direction.x -= 1;
    if (keys[directionActions.rightward]) direction.x += 1;

    // 방향이 없으면 기본 전방으로 설정
    if (direction.length() === 0) {
      direction.z = -1;
    } else {
      direction.normalize();
    }

    return direction;
  }, [getKeys, directionActions]);

  // 투사체 시작 위치 얻기
  const getStartPosition = useCallback(() => {
    const { startPosition } = options;
    if (!startPosition) return new Vector3(0, 1, 0);

    return typeof startPosition === "function"
      ? startPosition()
      : startPosition.clone();
  }, [options]);

  // 투사체 목표 위치 계산
  const calculateTargetPosition = useCallback(() => {
    const { targetPosition } = options;

    // 명시적 타겟 위치가 있으면 사용
    if (targetPosition) {
      return typeof targetPosition === "function"
        ? targetPosition()
        : targetPosition.clone();
    }

    // 아니면 방향에 따라 타겟 계산
    const startPos = getStartPosition();
    const direction = calculateDirection();
    const distance = 50; // 기본 발사 거리

    return new Vector3().copy(startPos).addScaledVector(direction, distance);
  }, [options, getStartPosition, calculateDirection]);

  // 투사체 발사 함수
  const fireProjectile = useCallback(() => {
    const startPos = getStartPosition();
    const targetPos = calculateTargetPosition();

    // 이펙트 스토어에 투사체 이펙트 추가
    addEffect(
      projectileType,
      account, // 발사자 ID
      {
        startPosition: startPos,
        endPosition: targetPos,
        speed: projectileSpeed,
        // 추가 설정은 필요에 따라 확장 가능
      }
    );

    // 필요하다면 서버에 이펙트 이벤트 전송
    if (server && server.room) {
      server.sendRoomMessage(server.room.id, "effect-event", {
        type: projectileType,
        sender: account,
        config: {
          startPosition: startPos,
          endPosition: targetPos,
          speed: projectileSpeed,
        },
      });
    }
  }, [
    getStartPosition,
    calculateTargetPosition,
    addEffect,
    projectileType,
    projectileSpeed,
    server,
    account,
  ]);

  // 발사 액션 키 입력 감지
  useEffect(() => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => {
        if (pressed) {
          fireProjectile();
        }
      }
    );
  }, [subscribeKeys, fireAction, fireProjectile]);

  // 수동 발사 기능 제공
  return { fireProjectile };
}
```

사용 예시:

```tsx
// Game.tsx에서 사용 예시
import { KeyboardControls } from "@react-three/drei";
import { keyboardMap } from "../constants/controls";
import { useKeyboardProjectileControl } from "../hooks/useKeyboardProjectileControl";
import { EffectType } from "../types/effect";

function Game() {
  // 플레이어 위치를 얻는 함수 (실제 구현에 맞게 수정)
  const getPlayerPosition = () => {
    // playerRef나 playerStore에서 현재 플레이어 위치 반환
    return new Vector3(0, 1, 0);
  };

  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        {/* 기타 게임 컴포넌트들 */}

        {/* 키보드 입력으로 총알 발사 제어 */}
        <PlayerWithGun />

        {/* 이펙트 컨테이너 */}
        <EffectContainer />
      </Canvas>
    </KeyboardControls>
  );
}

// 총을 들고 있는 플레이어 컴포넌트
function PlayerWithGun() {
  // 키보드 1키('action1')로 총알 발사
  useKeyboardProjectileControl({
    projectileType: EffectType.BULLET,
    startPosition: getPlayerPosition,
    projectileSpeed: 20,
    fireAction: "action1",
  });

  // 키보드 2키('action2')로 파이어볼 발사
  useKeyboardProjectileControl({
    projectileType: EffectType.FIREBALL,
    startPosition: getPlayerPosition,
    projectileSpeed: 15,
    fireAction: "action2",
  });

  return null; // 렌더링은 다른 컴포넌트에서 처리
}
```

---

_**User**_

fireAction(키 입력)을 외부에서 받게 코드를 만든 이유가 뭔지 설명해주세요.

---

_**Assistant**_

---

`fireAction`을 외부 파라미터로 받도록 설계한 주요 이유는 다음과 같습니다:

1. **다중 무기 시스템 지원**: 하나의 플레이어가 여러 종류의 발사체(총알, 파이어볼, 번개 등)를 서로 다른 키로 발사할 수 있습니다. 예시에서 보듯이 `action1`은 총알, `action2`는 파이어볼로 쉽게 구성 가능합니다.

2. **키 매핑 중앙화**: 제공된 `controls.ts`에서 이미 키보드 매핑을 중앙 관리하고 있습니다. 이 구조와 일관성을 유지하기 위해 직접 키코드를 하드코딩하지 않고 액션 이름을 사용합니다.

3. **재구성 용이성**: 나중에 키 설정이 변경되더라도 이 훅의 내부 로직을 수정할 필요가 없습니다. 단지 `controls.ts`의 매핑만 업데이트하면 됩니다.

4. **테스트 용이성**: 실제 키보드 입력에 의존하지 않고 원하는 액션 이름을 전달하여 쉽게 테스트할 수 있습니다.

5. **재사용성 향상**: 동일한 훅을 여러 다른 컴포넌트나 상황에서 다른 키 설정으로 재사용할 수 있습니다.

이 설계 방식은 기존 `EffectContainer`가 다양한 이펙트 타입을 지원하는 방식과도 일관성이 있어, 전체 코드베이스의 구조적 통일성을 유지합니다.

---

_**User**_

직선으로 발사되는 로직을 구현한다고했을때 산탄발사, 곡선발사 등은 직선발사로직에서 변경가능하도록 하는게 좋을까요? 아니면 다 따로따로 vectorDB 화 하는것이 좋을까요?

---

_**Assistant**_

---

두 접근법 모두 장단점이 있지만, 제 추천은 다음과 같습니다:

### 핵심 로직은 공유하고, 패턴별 구현은 별도로 VectorDB화하는 하이브리드 접근법

**이유:**

1. **공통 인터페이스와 기본 기능**

   - 모든 발사 유형이 공유하는 인터페이스와 기본 로직을 담은 핵심 모듈 제공
   - 발사 시스템의 기본 구조를 통일하여 AI가 일관된 패턴을 인식하도록 함

2. **특화된 구현은 별도 모듈로**

   - 직선, 산탄, 곡선 등 각 발사 패턴의 고유한 구현을 별도 모듈로 VectorDB화
   - 각 패턴이 자체적으로 완전히 작동하도록 구성

3. **구체적인 예시 모듈**
   ```
   1. base-projectile-system (공통 인터페이스/기본 구조)
   2. straight-line-projectile (직선 발사 구현)
   3. shotgun-spread-projectile (산탄 발사 구현)
   4. curved-trajectory-projectile (곡선 발사 구현)
   ```

### 결정적 이유:

1. **AI 이해도**: AI는 연관된 여러 모듈을 조합해 이해하는 것보다 단일 목적의 명확한 코드를 더 잘 이해합니다.

2. **검색 효율성**: "산탄총 발사" 같은 특정 요청이 있을 때 정확한 모듈을 찾기 쉽습니다.

3. **유지보수성**: 각 발사 패턴은 독자적인 요구사항과 변경 주기를 가질 수 있습니다.

4. **확장성**: 새로운 발사 패턴을 기존 코드 수정 없이 추가할 수 있습니다.

5. **로직 단순화**: 각 모듈이 한 가지 패턴에만 집중하여 코드 복잡도가 낮아집니다.

이 접근법은 AI가 "곡선으로 총 쏘게 해줘"와 같은 요청을 받았을 때 정확한 모듈을 찾아 구현할 가능성을 극대화합니다.

---

_**User**_

여러 모듈을 조합해 이해하는것이 어렵다는것을 아는데 base-projectile-system을 둔 이유가 뭔지 설명해줘

---

_**Assistant**_

---

`base-projectile-system`을 두는 이유는 다음과 같습니다:

1. **최소 공통 분모 제공**: 각 발사 패턴이 완전히 독립적이면서도, 가장 기본적인 인터페이스(시작점, 목표점, 속도)와 이펙트 시스템 연동 방식의 중복을 줄입니다.

2. **AI 이해 시작점**: AI가 코드베이스의 발사 시스템을 처음 접할 때 "어떻게 이펙트 시스템과 연결되는지"를 이해할 수 있는 출발점을 제공합니다.

3. **실패 대비책**: 특정 패턴의 모듈을 찾지 못했을 때 최소한 기본 발사는 구현할 수 있는 안전망 역할을 합니다.

4. **임베딩 효율**: 모든 발사 패턴에 공통된 용어와 개념을 담아 검색 시 관련 모듈을 더 잘 찾을 수 있게 합니다.

중요한 점은 `base-projectile-system`이 복잡한 추상 클래스나 상속 구조가 아니라, 단순히 기본 인터페이스와 이펙트 시스템 연동 방법을 보여주는 **참조 구현**이라는 것입니다. 각 패턴별 모듈은 이 기본 구현을 확장하는 것이 아니라 필요한 부분만 참고하여 독립적으로 작동해야 합니다.

---

_**User**_

좀 더 구체적인 예를 들어주세요

---

_**Assistant**_

---

# 구체적인 VectorDB 모듈 예시

## 1. `base-projectile-system` (참조 가이드)

```typescript
// MODULE_ID: base-projectile-system
// DESCRIPTION: 발사 시스템 구현을 위한 기본 참조 가이드
// KEYWORDS: 발사, 투사체, 이펙트, 기본, 연동

/**
 * 발사 시스템 구현 시 따라야 할 기본 인터페이스와 연동 방법
 *
 * 이 코드는 직접 사용하지 않고 참조용으로만 활용합니다.
 * 각 구체적 발사 패턴은 이 구조를 참고하여 독립적으로 구현합니다.
 */

// 1. 모든 발사 시스템에 필요한 기본 파라미터
interface ProjectileParams {
  startPosition: Vector3; // 발사 시작 위치
  endPosition: Vector3; // 발사 목표 위치
  speed: number; // 투사체 속도
  type: EffectType; // 투사체 유형 (BULLET, FIREBALL 등)
}

// 2. 이펙트 시스템과 연동하는 기본 방법
function launchProjectile(params: ProjectileParams) {
  const { startPosition, endPosition, speed, type } = params;

  // 이펙트 스토어에 추가
  addEffect(
    type,
    account, // 발사자 ID
    {
      startPosition,
      endPosition,
      speed,
      // 구체적 발사 패턴에 따라 추가 파라미터 설정
    }
  );

  // 멀티플레이어 환경에서 이벤트 발송
  if (server && server.room) {
    server.sendRoomMessage(server.room.id, "effect-event", {
      type,
      sender: account,
      config: {
        startPosition,
        endPosition,
        speed,
      },
    });
  }
}

// 3. 키보드 컨트롤 연동 방법 참고
function useKeyboardProjectileControl() {
  // useKeyboardControls 훅 사용
  // 발사 키 입력 감지
  // launchProjectile 함수 호출
}
```

## 2. `straight-line-projectile` (직선 발사 - 독립적 구현)

```typescript
// MODULE_ID: straight-line-projectile
// DESCRIPTION: 키보드로 직선 발사하는 완전한 구현
// KEYWORDS: 직선, 발사, 총, 키보드, 투사체

import { useEffect, useCallback } from "react";
import { Vector3 } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { useEffectStore } from "../store/effectStore";
import { EffectType } from "../types/effect";
import { useGameServer } from "@agent8/gameserver";

/**
 * 키보드로 직선 발사체를 쏘는 훅
 */
export function useStraightLineProjectile(options: {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
}) {
  const {
    startPosition,
    projectileType = EffectType.BULLET,
    projectileSpeed = 15,
    fireAction = "action1",
  } = options;

  const addEffect = useEffectStore((state) => state.addEffect);
  const { server, account } = useGameServer();
  const [subscribeKeys, getKeys] = useKeyboardControls();

  // 시작 위치 얻기
  const getStartPos = useCallback(() => {
    return typeof startPosition === "function"
      ? startPosition()
      : startPosition;
  }, [startPosition]);

  // 발사 방향 계산
  const calculateDirection = useCallback(() => {
    const keys = getKeys();
    const direction = new Vector3(0, 0, 0);

    if (keys.forward) direction.z -= 1;
    if (keys.backward) direction.z += 1;
    if (keys.leftward) direction.x -= 1;
    if (keys.rightward) direction.x += 1;

    return direction.length() > 0
      ? direction.normalize()
      : new Vector3(0, 0, -1);
  }, [getKeys]);

  // 총알 발사
  const fireStraightShot = useCallback(() => {
    const start = getStartPos();
    const direction = calculateDirection();
    const end = new Vector3().copy(start).addScaledVector(direction, 50);

    addEffect(projectileType, account, {
      startPosition: start,
      endPosition: end,
      speed: projectileSpeed,
    });

    if (server?.room) {
      server.sendRoomMessage(server.room.id, "effect-event", {
        type: projectileType,
        sender: account,
        config: {
          startPosition: start,
          endPosition: end,
          speed: projectileSpeed,
        },
      });
    }
  }, [
    getStartPos,
    calculateDirection,
    addEffect,
    projectileType,
    projectileSpeed,
    server,
    account,
  ]);

  // 키 입력 구독
  useEffect(() => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => {
        if (pressed) fireStraightShot();
      }
    );
  }, [subscribeKeys, fireAction, fireStraightShot]);

  return { fireStraightShot };
}
```

## 3. `shotgun-spread-projectile` (산탄 발사 - 독립적 구현)

```typescript
// MODULE_ID: shotgun-spread-projectile
// DESCRIPTION: 키보드로 산탄 형태로 다중 투사체 발사
// KEYWORDS: 산탄, 샷건, 다중, 퍼짐, 발사

import { useEffect, useCallback } from "react";
import { Vector3 } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { useEffectStore } from "../store/effectStore";
import { EffectType } from "../types/effect";
import { useGameServer } from "@agent8/gameserver";

/**
 * 키보드로 산탄식 다중 발사체를 쏘는 훅
 */
export function useShotgunSpreadProjectile(options: {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  pelletCount?: number; // 발사할 총알 수
  spreadAngle?: number; // 퍼짐 각도 (라디안)
}) {
  const {
    startPosition,
    projectileType = EffectType.BULLET,
    projectileSpeed = 15,
    fireAction = "action2",
    pelletCount = 5,
    spreadAngle = Math.PI / 12, // 15도
  } = options;

  const addEffect = useEffectStore((state) => state.addEffect);
  const { server, account } = useGameServer();
  const [subscribeKeys, getKeys] = useKeyboardControls();

  const getStartPos = useCallback(() => {
    return typeof startPosition === "function"
      ? startPosition()
      : startPosition;
  }, [startPosition]);

  const calculateBaseDirection = useCallback(() => {
    const keys = getKeys();
    const direction = new Vector3(0, 0, 0);

    if (keys.forward) direction.z -= 1;
    if (keys.backward) direction.z += 1;
    if (keys.leftward) direction.x -= 1;
    if (keys.rightward) direction.x += 1;

    return direction.length() > 0
      ? direction.normalize()
      : new Vector3(0, 0, -1);
  }, [getKeys]);

  // 벡터 회전 (Y축 기준)
  const rotateVector = useCallback(
    (vector: Vector3, angle: number): Vector3 => {
      const x = vector.x * Math.cos(angle) - vector.z * Math.sin(angle);
      const z = vector.x * Math.sin(angle) + vector.z * Math.cos(angle);
      return new Vector3(x, vector.y, z).normalize();
    },
    []
  );

  // 산탄 발사
  const fireShotgunSpread = useCallback(() => {
    const start = getStartPos();
    const baseDirection = calculateBaseDirection();
    const distance = 30;

    // 여러 발사체를 퍼짐 각도로 발사
    for (let i = 0; i < pelletCount; i++) {
      // 각 발사체의 각도 계산 (중앙 기준으로 좌우 분포)
      const angle =
        (i - (pelletCount - 1) / 2) * (spreadAngle / (pelletCount - 1));
      const direction = rotateVector(baseDirection, angle);
      const end = new Vector3()
        .copy(start)
        .addScaledVector(direction, distance);

      // 이펙트 추가
      addEffect(projectileType, account, {
        startPosition: start,
        endPosition: end,
        speed: projectileSpeed,
      });

      // 서버에 이벤트 발송
      if (server?.room) {
        server.sendRoomMessage(server.room.id, "effect-event", {
          type: projectileType,
          sender: account,
          config: {
            startPosition: start,
            endPosition: end,
            speed: projectileSpeed,
          },
        });
      }
    }
  }, [
    getStartPos,
    calculateBaseDirection,
    rotateVector,
    pelletCount,
    spreadAngle,
    addEffect,
    projectileType,
    projectileSpeed,
    server,
    account,
  ]);

  // 키 입력 구독
  useEffect(() => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => {
        if (pressed) fireShotgunSpread();
      }
    );
  }, [subscribeKeys, fireAction, fireShotgunSpread]);

  return { fireShotgunSpread };
}
```

## 4. `curved-trajectory-projectile` (곡선 발사 - 독립적 구현)

```typescript
// MODULE_ID: curved-trajectory-projectile
// DESCRIPTION: 키보드로 포물선 궤적의 투사체 발사
// KEYWORDS: 포물선, 곡선, 궤적, 중력, 아크, 발사

import { useEffect, useCallback } from "react";
import { Vector3 } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { useEffectStore } from "../store/effectStore";
import { EffectType } from "../types/effect";
import { useGameServer } from "@agent8/gameserver";

/**
 * 키보드로 포물선 궤적의 발사체를 쏘는 훅
 */
export function useCurvedTrajectoryProjectile(options: {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  height?: number; // 포물선 최고점 높이
}) {
  const {
    startPosition,
    projectileType = EffectType.FIREBALL,
    projectileSpeed = 12,
    fireAction = "action3",
    height = 10, // 포물선 높이
  } = options;

  const addEffect = useEffectStore((state) => state.addEffect);
  const { server, account } = useGameServer();
  const [subscribeKeys, getKeys] = useKeyboardControls();

  const getStartPos = useCallback(() => {
    return typeof startPosition === "function"
      ? startPosition()
      : startPosition;
  }, [startPosition]);

  const calculateTargetPosition = useCallback(() => {
    const keys = getKeys();
    const direction = new Vector3(0, 0, 0);

    if (keys.forward) direction.z -= 1;
    if (keys.backward) direction.z += 1;
    if (keys.leftward) direction.x -= 1;
    if (keys.rightward) direction.x += 1;

    const normalizedDir =
      direction.length() > 0 ? direction.normalize() : new Vector3(0, 0, -1);

    const start = getStartPos();
    const distance = 40; // 목표 거리

    // 목표 지점
    return new Vector3().copy(start).addScaledVector(normalizedDir, distance);
  }, [getKeys, getStartPos]);

  // 포물선 발사
  const fireCurvedProjectile = useCallback(() => {
    const start = getStartPos();
    const end = calculateTargetPosition();

    // 중간 제어점 (포물선 높이를 결정)
    const controlPoint = new Vector3(
      (start.x + end.x) / 2, // x 중간점
      Math.max(start.y, end.y) + height, // 최고점 높이
      (start.z + end.z) / 2 // z 중간점
    );

    addEffect(projectileType, account, {
      startPosition: start,
      endPosition: end,
      speed: projectileSpeed,
      // 곡선 궤적을 위한 추가 파라미터
      trajectoryType: "curved",
      controlPoint: controlPoint,
    });

    if (server?.room) {
      server.sendRoomMessage(server.room.id, "effect-event", {
        type: projectileType,
        sender: account,
        config: {
          startPosition: start,
          endPosition: end,
          speed: projectileSpeed,
          trajectoryType: "curved",
          controlPoint: controlPoint,
        },
      });
    }
  }, [
    getStartPos,
    calculateTargetPosition,
    height,
    addEffect,
    projectileType,
    projectileSpeed,
    server,
    account,
  ]);

  // 키 입력 구독
  useEffect(() => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => {
        if (pressed) fireCurvedProjectile();
      }
    );
  }, [subscribeKeys, fireAction, fireCurvedProjectile]);

  return { fireCurvedProjectile };
}
```

## 사용 예시:

```tsx
// 게임 컴포넌트에서 사용
function Player() {
  // 직선 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 산탄 발사
  useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 7,
    fireAction: "action2",
  });

  // 포물선 발사
  useCurvedTrajectoryProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.FIREBALL,
    height: 8,
    fireAction: "action3",
  });

  // ... 플레이어 렌더링 로직
}
```

이처럼 각 발사 패턴은 완전히 독립적으로 구현되었지만, 인터페이스와 이펙트 연동 방식은 일관되게 유지됩니다. AI는 각 모듈을 개별적으로 이해하고 구현할 수 있으며, 필요한 발사 패턴만 정확히 검색하고 적용할 수 있습니다.

---

_**User**_

여기까지 구조 좋은데, 현재 구조를 입력처리부터 발사로직 구현까지 어떤식으로 어떻게 개발해야하는지 완벽하게 내게 다시 설명해줘

---

_**Assistant**_

---

# 발사 시스템 개발 가이드: 입력부터 이펙트까지

## 1. 전체 구조 개요

```
키보드 입력 → 발사 로직 모듈 → 이펙트 스토어 → 이펙트 컨테이너 → 렌더링
```

각 발사 패턴은 독립적인 모듈로 개발하되, 동일한 인터페이스와 이펙트 시스템 연동 방식을 따릅니다.

## 2. 단계별 구현 과정

### 단계 1: 키보드 입력 설정

**controls.ts**에 발사 액션 키를 정의합니다.

```typescript
// src/constants/controls.ts
export const keyboardMap: KeyboardControlsEntry[] = [
  // 기존 컨트롤
  { name: "forward", keys: ["ArrowUp", "KeyW"] },
  // ...

  // 발사 액션
  { name: "action1", keys: ["1"] }, // 직선 발사
  { name: "action2", keys: ["2"] }, // 산탄 발사
  { name: "action3", keys: ["3"] }, // 곡선 발사
];
```

### 단계 2: 발사 패턴별 모듈 개발

각 발사 패턴은 다음 구조로 개발합니다:

```typescript
// src/hooks/useXXXProjectile.ts

export function useXXXProjectile(options: {
  // 1. 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 2. 선택적 파라미터 (기본값 제공)
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;

  // 3. 패턴별 고유 파라미터
  // 예: pelletCount, spreadAngle, height 등
}) {
  // A. 옵션 및 훅 설정
  const {
    startPosition,
    projectileType = EffectType.BULLET,
    // ...기타 옵션들
  } = options;

  // 필요한 훅 사용
  const addEffect = useEffectStore((state) => state.addEffect);
  const { server, account } = useGameServer();
  const [subscribeKeys, getKeys] = useKeyboardControls();

  // B. 발사 로직 구현
  const fireProjectile = useCallback(
    () => {
      // 1) 시작 위치 가져오기
      const start =
        typeof startPosition === "function" ? startPosition() : startPosition;

      // 2) 방향/목표 계산 (패턴별 로직)
      const direction = calculateDirection();
      const end = calculateEndPosition(start, direction);

      // 3) 이펙트 스토어에 추가
      addEffect(projectileType, account, {
        startPosition: start,
        endPosition: end,
        speed: projectileSpeed,
        // 패턴별 추가 설정
      });

      // 4) 멀티플레이어 이벤트 전송
      if (server?.room) {
        server.sendRoomMessage(/* 동일한 설정 */);
      }
    },
    [
      /* 의존성 */
    ]
  );

  // C. 키보드 입력 구독
  useEffect(() => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => {
        if (pressed) fireProjectile();
      }
    );
  }, [subscribeKeys, fireAction, fireProjectile]);

  // D. 외부 호출용 발사 함수 제공
  return { fireProjectile };
}
```

### 단계 3: 이펙트 컨트롤러 확인/개발

발사 패턴이 생성하는 이펙트 타입에 맞는 이펙트 컨트롤러가 있는지 확인합니다.

```typescript
// src/components/effects/XXXEffectController.tsx

export function XXXEffectController({ config, onHit, onComplete }: Props) {
  // 이펙트 컨트롤러 구현
  // config에서 startPosition, endPosition, speed 등을 사용

  return (
    <XXXEffect
      position={currentPosition}
      /* 기타 속성 */
    />
  );
}
```

### 단계 4: 게임 컴포넌트에서 발사 모듈 사용

```typescript
// src/components/Player.tsx

function Player() {
  // 플레이어 위치 참조
  const playerRef = useRef();

  // 플레이어 위치 가져오기
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 직선 발사 사용
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 필요한 다른 발사 패턴 추가

  return (
    <mesh ref={playerRef} position={[0, 1, 0]}>
      {/* 플레이어 모델 */}
    </mesh>
  );
}
```

### 단계 5: 키보드 컨트롤과 이펙트 컨테이너 연결

```typescript
// src/components/Game.tsx

function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        {/* 월드, 카메라 등 */}

        {/* 플레이어 */}
        <Player />

        {/* 이펙트 컨테이너 */}
        <EffectContainer />
      </Canvas>
    </KeyboardControls>
  );
}
```

## 3. 구현 체크리스트

각 발사 패턴 모듈 개발 시 다음을 확인하세요:

1. **입력 처리**

   - KeyboardControls 구성
   - useKeyboardControls 구독 설정
   - 키 입력으로 발사 함수 호출

2. **발사 로직**

   - 시작 위치 결정 (함수 또는 값)
   - 방향 계산 (키보드 입력 기반)
   - 목표 위치 계산 (패턴별 로직)
   - 추가 파라미터 설정 (패턴별 특성)

3. **이펙트 시스템 연동**

   - 이펙트 스토어에 투사체 추가
   - 필요한 config 파라미터 전달
   - 멀티플레이어 이벤트 전송

4. **코드 품질**
   - 옵션의 기본값 제공
   - 타입 정의 명확화
   - 필수/선택적 파라미터 구분
   - useCallback으로 메모이제이션

## 4. VectorDB 모듈화 전략

각 발사 패턴을 완전히 독립적인 모듈로 VectorDB화하되, 다음 정보를 함께 저장:

1. **모듈 ID**: 고유 식별자 (예: "straight-line-projectile")
2. **설명**: 간결한 기능 설명
3. **키워드**: 검색을 위한 관련 단어들
4. **사용 예시**: 간단한 구현 예시
5. **필요 의존성**: 필요한 패키지나 모듈 목록
6. **연관 이펙트**: 호환되는 이펙트 타입들

이렇게 개발하면 AI가 "총 쏘게 해줘"와 같은 요청을 받았을 때 적절한 발사 패턴 모듈을 찾아 구현할 수 있습니다.

---

_**User**_

개발을 시작하기전에 해당 내용을 문서로 정리하려고합니다. 뭘 개발하는지에 대한 개요부터 개발 목적 개발 내용 들의 내용들을 개발자답게 완벽하게 문서화해주세요.

---

_**Assistant**_

---

# 기술 문서: 모듈형 투사체 발사 시스템

## 1. 개요

본 문서는 React Three Fiber 기반 3D 게임 환경에서 다양한 투사체 발사 패턴을 구현하기 위한 모듈형 시스템의 설계 및 구현 가이드를 제공합니다. 이 시스템은 키보드 입력 처리부터 시각적 이펙트 렌더링까지의 전체 파이프라인을 정의합니다.

## 2. 개발 목적

- **유연한 발사 메커니즘**: 다양한 투사체 발사 패턴(직선, 산탄, 곡선 등)을 독립적으로 구현하면서도 일관된 인터페이스 제공
- **AI 검색 최적화**: 각 발사 패턴을 독립적 모듈로 VectorDB화하여 AI가 정확한 구현을 제공할 수 있도록 함
- **재사용성 증대**: 여러 프로젝트에서 쉽게 활용할 수 있는 모듈식 구조 설계
- **멀티플레이어 호환성**: 다른 플레이어에게도 발사 이벤트가 동기화되도록 설계

## 3. 시스템 아키텍처

### 3.1 전체 파이프라인

```
입력 감지 → 발사 로직 → 이펙트 생성 → 시각적 렌더링 → 충돌 처리
```

### 3.2 핵심 컴포넌트

1. **키보드 입력 레이어**: `@react-three/drei`의 `KeyboardControls` 활용
2. **발사 로직 모듈**: 패턴별 독립적 React 훅
3. **이펙트 시스템**: Zustand 기반 이펙트 스토어 및 `EffectContainer`
4. **이펙트 컨트롤러**: 투사체 유형별 시각적/물리적 동작 정의
5. **네트워크 레이어**: 멀티플레이어 동기화 처리

### 3.3 데이터 흐름

```
useXXXProjectile → addEffect → EffectStore → EffectContainer → XXXEffectController → 렌더링/물리
```

## 4. 구현 상세

### 4.1 발사 패턴 모듈

각 발사 패턴은 다음 형식의 독립적 훅으로 구현:

```typescript
function useXXXProjectile(options: ProjectileOptions): {
  fireProjectile: () => void;
};
```

#### 공통 인터페이스

```typescript
interface ProjectileOptions {
  // 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 공통 선택적 파라미터
  projectileType?: EffectType; // 투사체 유형
  projectileSpeed?: number; // 속도
  fireAction?: string; // 발사 키 액션

  // 패턴별 고유 파라미터
  [key: string]: any;
}
```

### 4.2 주요 발사 패턴

#### A. 직선 발사 (Straight Line)

- **설명**: 현재 방향으로 직선 경로의 투사체 발사
- **고유 파라미터**: 없음 (기본 구현)
- **모듈명**: `useStraightLineProjectile`

#### B. 산탄 발사 (Shotgun Spread)

- **설명**: 원뿔 형태로 다수의 투사체 동시 발사
- **고유 파라미터**: `pelletCount`, `spreadAngle`
- **모듈명**: `useShotgunSpreadProjectile`

#### C. 곡선 발사 (Curved Trajectory)

- **설명**: 포물선 형태의 궤적을 그리는 투사체 발사
- **고유 파라미터**: `height`, `gravity`
- **모듈명**: `useCurvedTrajectoryProjectile`

### 4.3 이펙트 시스템 연동

모든 발사 패턴은 이펙트 스토어에 투사체를 다음 형식으로 추가:

```typescript
addEffect(
  projectileType, // 이펙트 유형 (BULLET, FIREBALL 등)
  account, // 발사자 ID
  {
    startPosition, // 시작 위치
    endPosition, // 도착 위치
    speed, // 속도
    ...additionalParams, // 패턴별 추가 파라미터
  }
);
```

## 5. 개발 가이드라인

### 5.1 새로운 발사 패턴 추가 절차

1. **훅 생성**: `useXXXProjectile.ts` 파일에 새 발사 패턴 훅 구현
2. **이펙트 컨트롤러 확인**: 해당 투사체 유형의 컨트롤러가 있는지 확인, 없으면 구현
3. **테스트**: 독립적으로 패턴 기능 테스트
4. **VectorDB 문서화**: 검색을 위한 메타데이터 및 설명 추가

### 5.2 코드 품질 요구사항

- **타입 안전성**: 모든 인터페이스에 TypeScript 타입 정의
- **메모이제이션**: 성능 최적화를 위해 `useCallback`, `useMemo` 적절히 사용
- **에러 처리**: 잘못된 입력 처리 및 예외 상황 대응
- **코드 분리**: 각 기능을 명확히 분리하여 단일 책임 원칙 준수

### 5.3 VectorDB 최적화

각 모듈은 다음 메타데이터와 함께 VectorDB에 저장:

```json
{
  "id": "module-id",
  "title": "모듈 제목",
  "description": "기능 설명",
  "keywords": ["관련", "키워드", "목록"],
  "code": "// 실제 코드",
  "usage": "// 사용 예시"
}
```

## 6. 사용 예시

### 6.1 기본 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 1번 키로 직선 총알 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 2번 키로 산탄 발사
  useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 5,
    spreadAngle: Math.PI / 12,
    fireAction: "action2",
  });

  return <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>;
}
```

### 6.2 게임 통합

```tsx
function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        <Player />
        <EffectContainer />
        {/* 기타 게임 요소 */}
      </Canvas>
    </KeyboardControls>
  );
}
```

## 7. 확장 계획

### 7.1 추가 발사 패턴

- **추적 미사일** (Homing Missile): 목표를 추적하는 투사체
- **레이저 빔** (Continuous Beam): 지속적 피해를 주는 레이저
- **체인 라이트닝** (Chain Lightning): 여러 대상에게 연쇄적으로 퍼지는 번개

### 7.2 성능 최적화

- **오브젝트 풀링**: 투사체 재사용으로 메모리 효율화
- **LOD 시스템**: 거리에 따른 상세도 조절

### 7.3 추가 기능

- **충전 시스템**: 키를 누르는 시간에 따라 파워 조절
- **쿨다운 관리**: 발사 간 대기 시간 설정
- **탄약 시스템**: 제한된 발사 횟수 관리

## 8. 결론

이 모듈형 발사 시스템은 다양한 투사체 패턴을 독립적으로 구현하면서도 일관된 인터페이스를 유지합니다. 각 패턴을 VectorDB에 독립적으로 저장함으로써 AI가 특정 요구사항에 맞는 구현을 정확히 제공할 수 있으며, 게임 전체의 확장성과 유지보수성을 향상시킵니다.

---

## 부록: 주요 인터페이스 및 타입 정의

```typescript
// 발사 옵션 인터페이스
interface ProjectileOptions {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  [key: string]: any;
}

// 이펙트 타입 열거형
enum EffectType {
  BULLET,
  FIREBALL,
  LIGHTNING,
  METEOR,
  // 기타 이펙트 타입
}

// 이펙트 설정 인터페이스
interface EffectConfig {
  startPosition: Vector3;
  endPosition: Vector3;
  speed: number;
  [key: string]: any;
}
```

---

_**User**_

md 형식으로 복사할수있게 만들어주고 개발 목록을 만들어 하나씩 체크하며 완료할수있게해주세요.

---

_**Assistant**_

---

```markdown
# 기술 문서: 모듈형 투사체 발사 시스템

## 1. 개요

본 문서는 React Three Fiber 기반 3D 게임 환경에서 다양한 투사체 발사 패턴을 구현하기 위한 모듈형 시스템의 설계 및 구현 가이드를 제공합니다. 이 시스템은 키보드 입력 처리부터 시각적 이펙트 렌더링까지의 전체 파이프라인을 정의합니다.

## 2. 개발 목적

- **유연한 발사 메커니즘**: 다양한 투사체 발사 패턴(직선, 산탄, 곡선 등)을 독립적으로 구현하면서도 일관된 인터페이스 제공
- **AI 검색 최적화**: 각 발사 패턴을 독립적 모듈로 VectorDB화하여 AI가 정확한 구현을 제공할 수 있도록 함
- **재사용성 증대**: 여러 프로젝트에서 쉽게 활용할 수 있는 모듈식 구조 설계
- **멀티플레이어 호환성**: 다른 플레이어에게도 발사 이벤트가 동기화되도록 설계

## 3. 시스템 아키텍처

### 3.1 전체 파이프라인
```

입력 감지 → 발사 로직 → 이펙트 생성 → 시각적 렌더링 → 충돌 처리

```

### 3.2 핵심 컴포넌트

1. **키보드 입력 레이어**: `@react-three/drei`의 `KeyboardControls` 활용
2. **발사 로직 모듈**: 패턴별 독립적 React 훅
3. **이펙트 시스템**: Zustand 기반 이펙트 스토어 및 `EffectContainer`
4. **이펙트 컨트롤러**: 투사체 유형별 시각적/물리적 동작 정의
5. **네트워크 레이어**: 멀티플레이어 동기화 처리

### 3.3 데이터 흐름

```

useXXXProjectile → addEffect → EffectStore → EffectContainer → XXXEffectController → 렌더링/물리

````

## 4. 구현 상세

### 4.1 발사 패턴 모듈

각 발사 패턴은 다음 형식의 독립적 훅으로 구현:

```typescript
function useXXXProjectile(options: ProjectileOptions): { fireProjectile: () => void }
````

#### 공통 인터페이스

```typescript
interface ProjectileOptions {
  // 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 공통 선택적 파라미터
  projectileType?: EffectType; // 투사체 유형
  projectileSpeed?: number; // 속도
  fireAction?: string; // 발사 키 액션

  // 패턴별 고유 파라미터
  [key: string]: any;
}
```

### 4.2 주요 발사 패턴

#### A. 직선 발사 (Straight Line)

- **설명**: 현재 방향으로 직선 경로의 투사체 발사
- **고유 파라미터**: 없음 (기본 구현)
- **모듈명**: `useStraightLineProjectile`

#### B. 산탄 발사 (Shotgun Spread)

- **설명**: 원뿔 형태로 다수의 투사체 동시 발사
- **고유 파라미터**: `pelletCount`, `spreadAngle`
- **모듈명**: `useShotgunSpreadProjectile`

#### C. 곡선 발사 (Curved Trajectory)

- **설명**: 포물선 형태의 궤적을 그리는 투사체 발사
- **고유 파라미터**: `height`, `gravity`
- **모듈명**: `useCurvedTrajectoryProjectile`

### 4.3 이펙트 시스템 연동

모든 발사 패턴은 이펙트 스토어에 투사체를 다음 형식으로 추가:

```typescript
addEffect(
  projectileType, // 이펙트 유형 (BULLET, FIREBALL 등)
  account, // 발사자 ID
  {
    startPosition, // 시작 위치
    endPosition, // 도착 위치
    speed, // 속도
    ...additionalParams, // 패턴별 추가 파라미터
  }
);
```

## 5. 개발 체크리스트

### 5.1 초기 설정 및 타입 정의

- [ ] ProjectileOptions 인터페이스 정의
- [ ] 발사 패턴별 고유 옵션 인터페이스 정의
- [ ] effectStore에 필요한 타입 확장 (필요시)

### 5.2 직선 발사 모듈 개발

- [ ] useStraightLineProjectile 훅 구현
- [ ] 키보드 입력 구독 로직 구현
- [ ] 방향 계산 로직 구현
- [ ] 이펙트 스토어 통합
- [ ] 멀티플레이어 이벤트 발송 구현
- [ ] 단위 테스트 작성

### 5.3 산탄 발사 모듈 개발

- [ ] useShotgunSpreadProjectile 훅 구현
- [ ] 퍼짐 각도 계산 로직 구현
- [ ] 다중 투사체 생성 로직 구현
- [ ] 이펙트 스토어 통합
- [ ] 멀티플레이어 이벤트 발송 구현
- [ ] 단위 테스트 작성

### 5.4 곡선 발사 모듈 개발

- [ ] useCurvedTrajectoryProjectile 훅 구현
- [ ] 포물선 제어점 계산 로직 구현
- [ ] 이펙트 스토어 통합
- [ ] 멀티플레이어 이벤트 발송 구현
- [ ] 단위 테스트 작성

### 5.5 이펙트 컨트롤러 검토/개발

- [ ] BulletEffectController 검토 및 필요시 수정
- [ ] FireBallEffectController 검토 및 필요시 수정
- [ ] 곡선 투사체용 컨트롤러 개발 (필요시)

### 5.6 통합 및 테스트

- [ ] 게임 컴포넌트에 모듈 통합
- [ ] 키보드 컨트롤 설정과 동작 확인
- [ ] 다양한 발사 패턴 조합 테스트
- [ ] 멀티플레이어 환경에서 동기화 테스트

### 5.7 VectorDB 최적화

- [ ] 직선 발사 모듈 메타데이터 작성 및 DB화
- [ ] 산탄 발사 모듈 메타데이터 작성 및 DB화
- [ ] 곡선 발사 모듈 메타데이터 작성 및 DB화
- [ ] 검색 키워드 최적화

### 5.8 문서화 및 예제

- [ ] 각 모듈 사용법 예제 작성
- [ ] README 업데이트
- [ ] JSDoc 주석 추가
- [ ] 튜토리얼 문서 작성

## 6. 사용 예시

### 6.1 기본 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 1번 키로 직선 총알 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 2번 키로 산탄 발사
  useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 5,
    spreadAngle: Math.PI / 12,
    fireAction: "action2",
  });

  return <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>;
}
```

### 6.2 게임 통합

```tsx
function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        <Player />
        <EffectContainer />
        {/* 기타 게임 요소 */}
      </Canvas>
    </KeyboardControls>
  );
}
```

## 7. 확장 계획

### 7.1 추가 발사 패턴

- [ ] 추적 미사일 (Homing Missile) 모듈 개발
- [ ] 레이저 빔 (Continuous Beam) 모듈 개발
- [ ] 체인 라이트닝 (Chain Lightning) 모듈 개발

### 7.2 성능 최적화

- [ ] 오브젝트 풀링 시스템 구현
- [ ] LOD 시스템 구현

### 7.3 추가 기능

- [ ] 충전 발사 시스템 구현
- [ ] 쿨다운 관리 시스템 구현
- [ ] 탄약 관리 시스템 구현

## 8. 결론

이 모듈형 발사 시스템은 다양한 투사체 패턴을 독립적으로 구현하면서도 일관된 인터페이스를 유지합니다. 각 패턴을 VectorDB에 독립적으로 저장함으로써 AI가 특정 요구사항에 맞는 구현을 정확히 제공할 수 있으며, 게임 전체의 확장성과 유지보수성을 향상시킵니다.

---

## 부록: 주요 인터페이스 및 타입 정의

```typescript
// 발사 옵션 인터페이스
interface ProjectileOptions {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  [key: string]: any;
}

// 이펙트 타입 열거형
enum EffectType {
  BULLET,
  FIREBALL,
  LIGHTNING,
  METEOR,
  // 기타 이펙트 타입
}

// 이펙트 설정 인터페이스
interface EffectConfig {
  startPosition: Vector3;
  endPosition: Vector3;
  speed: number;
  [key: string]: any;
}
```

````

---

_**User**_

이펙트 시스템이나 컨트롤러 네트워크 부분은 투사체 발사 시스템과 구조적으로 연결되어있긴 하지만 개발해야될 롤이 아니니 개발 목록등의 내용에서 제거해줘.

---

_**Assistant**_



---

```markdown
# 기술 문서: 모듈형 투사체 발사 시스템

## 1. 개요

본 문서는 React Three Fiber 기반 3D 게임 환경에서 다양한 투사체 발사 패턴을 구현하기 위한 모듈형 시스템의 설계 및 구현 가이드를 제공합니다. 이 시스템은 키보드 입력 처리부터 이펙트 스토어에 발사 요청을 전달하는 로직에 집중합니다.

## 2. 개발 목적

- **유연한 발사 메커니즘**: 다양한 투사체 발사 패턴(직선, 산탄, 곡선 등)을 독립적으로 구현하면서도 일관된 인터페이스 제공
- **AI 검색 최적화**: 각 발사 패턴을 독립적 모듈로 VectorDB화하여 AI가 정확한 구현을 제공할 수 있도록 함
- **재사용성 증대**: 여러 프로젝트에서 쉽게 활용할 수 있는 모듈식 구조 설계

## 3. 시스템 아키텍처

### 3.1 전체 파이프라인

````

입력 감지 → 발사 로직 → 이펙트 스토어에 발사 요청 전달

```

### 3.2 핵심 컴포넌트

1. **키보드 입력 레이어**: `@react-three/drei`의 `KeyboardControls` 활용
2. **발사 로직 모듈**: 패턴별 독립적 React 훅

### 3.3 데이터 흐름

```

useXXXProjectile → addEffect(기존 이펙트 스토어 활용)

````

## 4. 구현 상세

### 4.1 발사 패턴 모듈

각 발사 패턴은 다음 형식의 독립적 훅으로 구현:

```typescript
function useXXXProjectile(options: ProjectileOptions): { fireProjectile: () => void }
````

#### 공통 인터페이스

```typescript
interface ProjectileOptions {
  // 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 공통 선택적 파라미터
  projectileType?: EffectType; // 투사체 유형
  projectileSpeed?: number; // 속도
  fireAction?: string; // 발사 키 액션

  // 패턴별 고유 파라미터
  [key: string]: any;
}
```

### 4.2 주요 발사 패턴

#### A. 직선 발사 (Straight Line)

- **설명**: 현재 방향으로 직선 경로의 투사체 발사
- **고유 파라미터**: 없음 (기본 구현)
- **모듈명**: `useStraightLineProjectile`

#### B. 산탄 발사 (Shotgun Spread)

- **설명**: 원뿔 형태로 다수의 투사체 동시 발사
- **고유 파라미터**: `pelletCount`, `spreadAngle`
- **모듈명**: `useShotgunSpreadProjectile`

#### C. 곡선 발사 (Curved Trajectory)

- **설명**: 포물선 형태의 궤적을 그리는 투사체 발사
- **고유 파라미터**: `height`, `gravity`
- **모듈명**: `useCurvedTrajectoryProjectile`

### 4.3 이펙트 시스템 연동 참고

발사 패턴 모듈은 기존 이펙트 스토어와 다음과 같이 연동됩니다:

```typescript
addEffect(
  projectileType, // 이펙트 유형 (BULLET, FIREBALL 등)
  account, // 발사자 ID
  {
    startPosition, // 시작 위치
    endPosition, // 도착 위치
    speed, // 속도
    ...additionalParams, // 패턴별 추가 파라미터
  }
);
```

## 5. 개발 체크리스트

### 5.1 초기 설정 및 타입 정의

- [ ] ProjectileOptions 인터페이스 정의
- [ ] 발사 패턴별 고유 옵션 인터페이스 정의

### 5.2 직선 발사 모듈 개발

- [ ] useStraightLineProjectile 훅 구현
- [ ] 키보드 입력 구독 로직 구현
- [ ] 방향 계산 로직 구현
- [ ] 이펙트 스토어 연동
- [ ] 단위 테스트 작성

### 5.3 산탄 발사 모듈 개발

- [ ] useShotgunSpreadProjectile 훅 구현
- [ ] 퍼짐 각도 계산 로직 구현
- [ ] 다중 투사체 생성 로직 구현
- [ ] 이펙트 스토어 연동
- [ ] 단위 테스트 작성

### 5.4 곡선 발사 모듈 개발

- [ ] useCurvedTrajectoryProjectile 훅 구현
- [ ] 포물선 제어점 계산 로직 구현
- [ ] 이펙트 스토어 연동
- [ ] 단위 테스트 작성

### 5.5 통합 및 테스트

- [ ] 게임 컴포넌트에 모듈 통합
- [ ] 키보드 컨트롤 설정과 동작 확인
- [ ] 다양한 발사 패턴 조합 테스트

### 5.6 VectorDB 최적화

- [ ] 직선 발사 모듈 메타데이터 작성 및 DB화
- [ ] 산탄 발사 모듈 메타데이터 작성 및 DB화
- [ ] 곡선 발사 모듈 메타데이터 작성 및 DB화
- [ ] 검색 키워드 최적화

### 5.7 문서화 및 예제

- [ ] 각 모듈 사용법 예제 작성
- [ ] README 업데이트
- [ ] JSDoc 주석 추가
- [ ] 튜토리얼 문서 작성

## 6. 사용 예시

### 6.1 기본 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 1번 키로 직선 총알 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 2번 키로 산탄 발사
  useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 5,
    spreadAngle: Math.PI / 12,
    fireAction: "action2",
  });

  return <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>;
}
```

### 6.2 게임 통합

```tsx
function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        <Player />
        <EffectContainer /> {/* 기존 이펙트 컨테이너 */}
        {/* 기타 게임 요소 */}
      </Canvas>
    </KeyboardControls>
  );
}
```

## 7. 확장 계획

### 7.1 추가 발사 패턴

- [ ] 추적 미사일 (Homing Missile) 모듈 개발
- [ ] 레이저 빔 (Continuous Beam) 모듈 개발
- [ ] 체인 라이트닝 (Chain Lightning) 모듈 개발

### 7.2 추가 기능

- [ ] 충전 발사 시스템 구현
- [ ] 쿨다운 관리 시스템 구현
- [ ] 탄약 관리 시스템 구현

## 8. 결론

이 모듈형 발사 시스템은 다양한 투사체 패턴을 독립적으로 구현하면서도 일관된 인터페이스를 유지합니다. 각 패턴을 VectorDB에 독립적으로 저장함으로써 AI가 특정 요구사항에 맞는 구현을 정확히 제공할 수 있으며, 게임 전체의 확장성과 유지보수성을 향상시킵니다.

---

## 부록: 주요 인터페이스 및 타입 정의

```typescript
// 발사 옵션 인터페이스
interface ProjectileOptions {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  [key: string]: any;
}

// 이펙트 타입 열거형 (기존 시스템 참조)
enum EffectType {
  BULLET,
  FIREBALL,
  LIGHTNING,
  METEOR,
  // 기타 이펙트 타입
}
```

````

---

_**User**_

개발 체크리스트의 단위가 너무 작게 되어있습니다. 직선발사 모듈개발, 곡선발사 모듈개발 등의 좀 더 큰 단위로 묶어주세요.

---

_**Assistant**_



---

```markdown
# 기술 문서: 모듈형 투사체 발사 시스템

## 1. 개요

본 문서는 React Three Fiber 기반 3D 게임 환경에서 다양한 투사체 발사 패턴을 구현하기 위한 모듈형 시스템의 설계 및 구현 가이드를 제공합니다. 이 시스템은 키보드 입력 처리부터 이펙트 스토어에 발사 요청을 전달하는 로직에 집중합니다.

## 2. 개발 목적

- **유연한 발사 메커니즘**: 다양한 투사체 발사 패턴(직선, 산탄, 곡선 등)을 독립적으로 구현하면서도 일관된 인터페이스 제공
- **AI 검색 최적화**: 각 발사 패턴을 독립적 모듈로 VectorDB화하여 AI가 정확한 구현을 제공할 수 있도록 함
- **재사용성 증대**: 여러 프로젝트에서 쉽게 활용할 수 있는 모듈식 구조 설계

## 3. 시스템 아키텍처

### 3.1 전체 파이프라인

````

입력 감지 → 발사 로직 → 이펙트 스토어에 발사 요청 전달

```

### 3.2 핵심 컴포넌트

1. **키보드 입력 레이어**: `@react-three/drei`의 `KeyboardControls` 활용
2. **발사 로직 모듈**: 패턴별 독립적 React 훅

### 3.3 데이터 흐름

```

useXXXProjectile → addEffect(기존 이펙트 스토어 활용)

````

## 4. 구현 상세

### 4.1 발사 패턴 모듈

각 발사 패턴은 다음 형식의 독립적 훅으로 구현:

```typescript
function useXXXProjectile(options: ProjectileOptions): { fireProjectile: () => void }
````

#### 공통 인터페이스

```typescript
interface ProjectileOptions {
  // 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 공통 선택적 파라미터
  projectileType?: EffectType; // 투사체 유형
  projectileSpeed?: number; // 속도
  fireAction?: string; // 발사 키 액션

  // 패턴별 고유 파라미터
  [key: string]: any;
}
```

### 4.2 주요 발사 패턴

#### A. 직선 발사 (Straight Line)

- **설명**: 현재 방향으로 직선 경로의 투사체 발사
- **고유 파라미터**: 없음 (기본 구현)
- **모듈명**: `useStraightLineProjectile`

#### B. 산탄 발사 (Shotgun Spread)

- **설명**: 원뿔 형태로 다수의 투사체 동시 발사
- **고유 파라미터**: `pelletCount`, `spreadAngle`
- **모듈명**: `useShotgunSpreadProjectile`

#### C. 곡선 발사 (Curved Trajectory)

- **설명**: 포물선 형태의 궤적을 그리는 투사체 발사
- **고유 파라미터**: `height`, `gravity`
- **모듈명**: `useCurvedTrajectoryProjectile`

### 4.3 이펙트 시스템 연동 참고

발사 패턴 모듈은 기존 이펙트 스토어와 다음과 같이 연동됩니다:

```typescript
addEffect(
  projectileType, // 이펙트 유형 (BULLET, FIREBALL 등)
  account, // 발사자 ID
  {
    startPosition, // 시작 위치
    endPosition, // 도착 위치
    speed, // 속도
    ...additionalParams, // 패턴별 추가 파라미터
  }
);
```

## 5. 개발 체크리스트

- [ ] **공통 기반 구축**

  - 발사 시스템의 인터페이스 및 타입 정의
  - 키보드 입력과 연동하는 기본 구조 설계

- [ ] **직선 발사 모듈 (useStraightLineProjectile)**

  - 모듈 구현, 테스트 및 문서화
  - 이펙트 스토어 연동 및 검증

- [ ] **산탄 발사 모듈 (useShotgunSpreadProjectile)**

  - 모듈 구현, 테스트 및 문서화
  - 이펙트 스토어 연동 및 검증

- [ ] **곡선 발사 모듈 (useCurvedTrajectoryProjectile)**

  - 모듈 구현, 테스트 및 문서화
  - 이펙트 스토어 연동 및 검증

- [ ] **시스템 통합 및 검증**

  - 게임 컴포넌트에 모듈 통합
  - 다양한 발사 패턴 조합 테스트

- [ ] **VectorDB 최적화**

  - 발사 패턴 모듈별 메타데이터 작성 및 DB화
  - 검색 키워드 최적화

- [ ] **문서 및 예제 완성**
  - 사용 설명서 및 예제 코드 작성
  - API 문서화 완료

## 6. 사용 예시

### 6.1 기본 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 1번 키로 직선 총알 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
  });

  // 2번 키로 산탄 발사
  useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 5,
    spreadAngle: Math.PI / 12,
    fireAction: "action2",
  });

  return <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>;
}
```

### 6.2 게임 통합

```tsx
function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        <Player />
        <EffectContainer /> {/* 기존 이펙트 컨테이너 */}
        {/* 기타 게임 요소 */}
      </Canvas>
    </KeyboardControls>
  );
}
```

## 7. 확장 계획

- [ ] **추가 발사 패턴 개발**

  - 추적 미사일 (Homing Missile) 모듈
  - 레이저 빔 (Continuous Beam) 모듈
  - 체인 라이트닝 (Chain Lightning) 모듈

- [ ] **고급 기능 추가**
  - 충전 발사 시스템
  - 쿨다운 관리 시스템
  - 탄약 관리 시스템

## 8. 결론

이 모듈형 발사 시스템은 다양한 투사체 패턴을 독립적으로 구현하면서도 일관된 인터페이스를 유지합니다. 각 패턴을 VectorDB에 독립적으로 저장함으로써 AI가 특정 요구사항에 맞는 구현을 정확히 제공할 수 있으며, 게임 전체의 확장성과 유지보수성을 향상시킵니다.

---

## 부록: 주요 인터페이스 및 타입 정의

```typescript
// 발사 옵션 인터페이스
interface ProjectileOptions {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  [key: string]: any;
}

// 이펙트 타입 열거형 (기존 시스템 참조)
enum EffectType {
  BULLET,
  FIREBALL,
  LIGHTNING,
  METEOR,
  // 기타 이펙트 타입
}
```

````

---

_**User**_

입력 감지(키보드 입력, 마우스 입력) 개발에 대한 내용이 빠져있습니다.

---

_**Assistant**_



---

```markdown
# 기술 문서: 모듈형 투사체 발사 시스템

## 1. 개요

본 문서는 React Three Fiber 기반 3D 게임 환경에서 다양한 투사체 발사 패턴을 구현하기 위한 모듈형 시스템의 설계 및 구현 가이드를 제공합니다. 이 시스템은 키보드/마우스 입력 처리부터 이펙트 스토어에 발사 요청을 전달하는 로직에 집중합니다.

## 2. 개발 목적

- **유연한 발사 메커니즘**: 다양한 투사체 발사 패턴(직선, 산탄, 곡선 등)을 독립적으로 구현하면서도 일관된 인터페이스 제공
- **다양한 입력 지원**: 키보드와 마우스 모두 지원하는 입력 시스템 구현
- **AI 검색 최적화**: 각 발사 패턴을 독립적 모듈로 VectorDB화하여 AI가 정확한 구현을 제공할 수 있도록 함
- **재사용성 증대**: 여러 프로젝트에서 쉽게 활용할 수 있는 모듈식 구조 설계

## 3. 시스템 아키텍처

### 3.1 전체 파이프라인

````

입력 감지(키보드/마우스) → 발사 로직 → 이펙트 스토어에 발사 요청 전달

```

### 3.2 핵심 컴포넌트

1. **입력 처리 레이어**: 키보드와 마우스 입력을 감지하고 처리
   - 키보드: `@react-three/drei`의 `KeyboardControls` 활용
   - 마우스: 마우스 이벤트 및 레이캐스팅 처리
2. **발사 로직 모듈**: 패턴별 독립적 React 훅

### 3.3 데이터 흐름

```

입력 감지 → useXXXProjectile → addEffect(기존 이펙트 스토어 활용)

````

## 4. 구현 상세

### 4.1 입력 처리 시스템

#### A. 키보드 입력 처리
- **설명**: `KeyboardControls` 훅을 활용한 키 입력 감지 및 방향 계산
- **키 매핑**: `controls.ts`의 keyboardMap 활용
- **구현 방식**: `useKeyboardControls` 훅 사용

#### B. 마우스 입력 처리
- **설명**: 마우스 클릭 위치에 따른 발사 방향 및 목표점 계산
- **구현 방식**: 마우스 이벤트 및 레이캐스팅 활용
- **특징**: 3D 공간에서의 정확한 목표점 계산

### 4.2 발사 패턴 모듈

각 발사 패턴은 다음 형식의 독립적 훅으로 구현:

```typescript
function useXXXProjectile(options: ProjectileOptions): { fireProjectile: () => void }
````

#### 공통 인터페이스

```typescript
interface ProjectileOptions {
  // 필수 파라미터
  startPosition: Vector3 | (() => Vector3);

  // 공통 선택적 파라미터
  projectileType?: EffectType; // 투사체 유형
  projectileSpeed?: number; // 속도
  fireAction?: string; // 발사 키 액션 (키보드 사용 시)
  useMouseInput?: boolean; // 마우스 입력 사용 여부

  // 패턴별 고유 파라미터
  [key: string]: any;
}
```

### 4.3 주요 발사 패턴

#### A. 직선 발사 (Straight Line)

- **설명**: 현재 방향으로 직선 경로의 투사체 발사
- **고유 파라미터**: 없음 (기본 구현)
- **모듈명**: `useStraightLineProjectile`

#### B. 산탄 발사 (Shotgun Spread)

- **설명**: 원뿔 형태로 다수의 투사체 동시 발사
- **고유 파라미터**: `pelletCount`, `spreadAngle`
- **모듈명**: `useShotgunSpreadProjectile`

#### C. 곡선 발사 (Curved Trajectory)

- **설명**: 포물선 형태의 궤적을 그리는 투사체 발사
- **고유 파라미터**: `height`, `gravity`
- **모듈명**: `useCurvedTrajectoryProjectile`

### 4.4 이펙트 시스템 연동 참고

발사 패턴 모듈은 기존 이펙트 스토어와 다음과 같이 연동됩니다:

```typescript
addEffect(
  projectileType, // 이펙트 유형 (BULLET, FIREBALL 등)
  account, // 발사자 ID
  {
    startPosition, // 시작 위치
    endPosition, // 도착 위치
    speed, // 속도
    ...additionalParams, // 패턴별 추가 파라미터
  }
);
```

## 5. 개발 체크리스트

- [ ] **입력 처리 시스템 개발**

  - 키보드 입력 처리 모듈 구현 (KeyboardControls 연동)
  - 마우스 입력 처리 모듈 구현 (레이캐스팅 로직)
  - 입력 시스템 간 전환 메커니즘 구현

- [ ] **공통 기반 구축**

  - 발사 시스템의 인터페이스 및 타입 정의
  - 입력 시스템과 발사 로직 연동 구조 설계

- [ ] **직선 발사 모듈 (useStraightLineProjectile)**

  - 키보드 기반 직선 발사 구현
  - 마우스 기반 직선 발사 구현
  - 이펙트 스토어 연동 및 검증

- [ ] **산탄 발사 모듈 (useShotgunSpreadProjectile)**

  - 키보드 기반 산탄 발사 구현
  - 마우스 기반 산탄 발사 구현
  - 이펙트 스토어 연동 및 검증

- [ ] **곡선 발사 모듈 (useCurvedTrajectoryProjectile)**

  - 키보드 기반 곡선 발사 구현
  - 마우스 기반 곡선 발사 구현
  - 이펙트 스토어 연동 및 검증

- [ ] **시스템 통합 및 검증**

  - 게임 컴포넌트에 모듈 통합
  - 다양한 발사 패턴과 입력 방식 조합 테스트

- [ ] **VectorDB 최적화**

  - 입력 방식별 모듈 메타데이터 작성
  - 발사 패턴별 모듈 메타데이터 작성
  - 검색 키워드 최적화

- [ ] **문서 및 예제 완성**
  - 사용 설명서 및 예제 코드 작성
  - API 문서화 완료

## 6. 사용 예시

### 6.1 키보드 입력 기반 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 1번 키로 직선 총알 발사
  useStraightLineProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1",
    useMouseInput: false,
  });

  return <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>;
}
```

### 6.2 마우스 입력 기반 사용법

```tsx
function Player() {
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 마우스 클릭으로 산탄 발사
  const { fireProjectile } = useShotgunSpreadProjectile({
    startPosition: getPlayerPosition,
    projectileType: EffectType.BULLET,
    pelletCount: 5,
    spreadAngle: Math.PI / 12,
    useMouseInput: true,
  });

  return (
    <>
      <mesh ref={playerRef}>{/* 플레이어 렌더링 */}</mesh>
      <mesh
        onClick={(e) => {
          e.stopPropagation();
          fireProjectile();
        }}
      />
    </>
  );
}
```

### 6.3 게임 통합

```tsx
function Game() {
  return (
    <KeyboardControls map={keyboardMap}>
      <Canvas>
        <Player />
        <EffectContainer /> {/* 기존 이펙트 컨테이너 */}
        {/* 기타 게임 요소 */}
      </Canvas>
    </KeyboardControls>
  );
}
```

## 7. 확장 계획

- [ ] **추가 발사 패턴 개발**

  - 추적 미사일 (Homing Missile) 모듈
  - 레이저 빔 (Continuous Beam) 모듈
  - 체인 라이트닝 (Chain Lightning) 모듈

- [ ] **고급 입력 처리 기능**

  - 조준선(Aim Assist) 기능
  - 입력 조합(Combo) 기반 발사 패턴
  - 게임패드 지원

- [ ] **고급 기능 추가**
  - 충전 발사 시스템
  - 쿨다운 관리 시스템
  - 탄약 관리 시스템

## 8. 결론

이 모듈형 발사 시스템은 키보드와 마우스 입력을 모두 지원하면서 다양한 투사체 패턴을 독립적으로 구현합니다. 일관된 인터페이스를 유지하면서도 각 패턴을 VectorDB에 독립적으로 저장함으로써 AI가 특정 요구사항에 맞는 구현을 정확히 제공할 수 있으며, 게임 전체의 확장성과 유지보수성을 향상시킵니다.

---

## 부록: 주요 인터페이스 및 타입 정의

```typescript
// 발사 옵션 인터페이스
interface ProjectileOptions {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  useMouseInput?: boolean;
  [key: string]: any;
}

// 이펙트 타입 열거형 (기존 시스템 참조)
enum EffectType {
  BULLET,
  FIREBALL,
  LIGHTNING,
  METEOR,
  // 기타 이펙트 타입
}

// 마우스 입력 처리 인터페이스
interface MouseInputHandler {
  getTargetPosition(event: MouseEvent): Vector3 | null;
  isTriggered(event: MouseEvent): boolean;
}
```

````

---

_**User**_

이제 하나씩 개발을 시작합시다.
입력처리 시스템중에 키보드 입력처리 시스템의 코드스니펫을 작성해주세요.(AI가 완벅하게 이해하고 구현 할 수 있도록)

---

_**Assistant**_



---

```typescript
// src/hooks/useKeyboardInputHandler.ts
import { useCallback } from "react";
import { Vector3 } from "three";
import { useKeyboardControls } from "@react-three/drei";

/**
 * 키보드 입력을 처리하여 발사 방향과 발사 트리거를 제공하는 훅
 *
 * @param options 설정 옵션
 * @returns 방향 및 트리거 관련 함수들
 */
export function useKeyboardInputHandler(options: {
  /** 발사 액션 키 이름 (예: "action1", "action2") */
  fireAction?: string;
  /** 움직임 컨트롤 키 설정 */
  movementControls?: {
    forward?: string;
    backward?: string;
    leftward?: string;
    rightward?: string;
  };
  /** Y 축 방향 고정 여부 (true면 수평 방향만 계산) */
  lockYAxis?: boolean;
}) {
  const {
    fireAction = "action1",
    movementControls = {
      forward: "forward",
      backward: "backward",
      leftward: "leftward",
      rightward: "rightward"
    },
    lockYAxis = true
  } = options;

  // @react-three/drei의 키보드 컨트롤 훅 사용
  const [subscribeKeys, getKeys] = useKeyboardControls();

  /**
   * 현재 키보드 입력 상태에 따라 발사 방향 벡터 계산
   * @returns 정규화된 방향 벡터
   */
  const calculateDirection = useCallback(() => {
    const keys = getKeys();
    const direction = new Vector3(0, 0, 0);

    // 키 입력 기반 방향 계산
    if (keys[movementControls.forward]) direction.z -= 1;
    if (keys[movementControls.backward]) direction.z += 1;
    if (keys[movementControls.leftward]) direction.x -= 1;
    if (keys[movementControls.rightward]) direction.x += 1;

    // Y축 제한이 없고 추가 상하 컨트롤이 있는 경우 (예: "up"/"down" 키 등)
    if (!lockYAxis) {
      // 여기에 Y축 제어 로직 추가 가능
    }

    // 아무 방향 키도 누르지 않은 경우 기본 전방 방향
    if (direction.length() === 0) {
      direction.z = -1; // 기본 전방 방향
    } else {
      direction.normalize(); // 방향 정규화
    }

    return direction;
  }, [getKeys, movementControls, lockYAxis]);

  /**
   * 지정된 목표 위치까지의 방향 벡터 계산
   * @param startPosition 시작 위치
   * @param distance 목표 거리
   * @returns 목표 위치 벡터
   */
  const calculateTargetPosition = useCallback((startPosition: Vector3, distance: number = 50) => {
    const direction = calculateDirection();
    return new Vector3().copy(startPosition).addScaledVector(direction, distance);
  }, [calculateDirection]);

  /**
   * 발사 키가 눌렸는지 확인
   * @returns 발사 키 눌림 상태
   */
  const isFireTriggered = useCallback(() => {
    const keys = getKeys();
    return !!keys[fireAction];
  }, [getKeys, fireAction]);

  /**
   * 지정된 키가 눌렸는지 확인
   * @param keyName 확인할 키 이름
   * @returns 키 눌림 상태
   */
  const isKeyPressed = useCallback((keyName: string) => {
    const keys = getKeys();
    return !!keys[keyName];
  }, [getKeys]);

  /**
   * 발사 키 입력 구독 함수
   * @param callback 키 상태 변경 시 호출할 콜백
   * @returns 구독 해제 함수
   */
  const subscribeToFireAction = useCallback((callback: (pressed: boolean) => void) => {
    return subscribeKeys(
      (state) => state[fireAction],
      (pressed) => callback(pressed)
    );
  }, [subscribeKeys, fireAction]);

  return {
    /** 키보드 입력에 따른 방향 벡터 계산 */
    calculateDirection,
    /** 시작점에서 계산된 방향으로의 목표점 계산 */
    calculateTargetPosition,
    /** 발사 키가 눌렸는지 확인 */
    isFireTriggered,
    /** 특정 키가 눌렸는지 확인 */
    isKeyPressed,
    /** 발사 키 입력 이벤트 구독 */
    subscribeToFireAction,
    /** 원시 키보드 상태 접근 함수 */
    getKeys
  };
}
````

### 사용 예시:

```typescript
// Player.tsx에서 사용 예시
function Player() {
  const playerRef = useRef<THREE.Mesh>(null);

  // 플레이어 위치 가져오기
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 키보드 입력 핸들러 사용
  const { calculateDirection, calculateTargetPosition, subscribeToFireAction } =
    useKeyboardInputHandler({
      fireAction: "action1", // 1번 키로 발사
      lockYAxis: true, // 수평 방향만 사용
    });

  // 발사 효과 생성 함수
  const shootProjectile = useCallback(() => {
    const startPos = getPlayerPosition();
    const endPos = calculateTargetPosition(startPos, 30);

    // 이펙트 스토어에 발사 요청
    addEffect(EffectType.BULLET, account, {
      startPosition: startPos,
      endPosition: endPos,
      speed: 20,
    });
  }, [getPlayerPosition, calculateTargetPosition, addEffect, account]);

  // 발사 키 입력 구독
  useEffect(() => {
    return subscribeToFireAction((pressed) => {
      if (pressed) {
        shootProjectile();
      }
    });
  }, [subscribeToFireAction, shootProjectile]);

  return (
    <mesh ref={playerRef} position={[0, 1, 0]}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="blue" />
    </mesh>
  );
}
```

이 코드는 `@react-three/drei`의 `useKeyboardControls`를 활용하여 키보드 입력을 처리하고, 방향 계산과 발사 트리거 감지 기능을 제공합니다. 명확한 인터페이스와 자세한 JSDoc 주석으로 AI가 쉽게 이해하고 구현할 수 있도록 했습니다.

---

_**User**_

movementControls 즉 키보드입력으로 방향을 얻어오면 안되고 Player 캐릭터의 RigidBody 에서 방향을 얻어오는 방식으로 사용해야할것같습니다.

---

_**Assistant**_

---

```typescript
// src/hooks/useKeyboardInputHandler.ts
import { useCallback, MutableRefObject } from "react";
import { Vector3, Object3D, Quaternion } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { RigidBody } from "@dimforge/rapier3d-compat";

/**
 * 키보드 입력을 처리하고 RigidBody 방향을 활용하여 발사 방향과 발사 트리거를 제공하는 훅
 *
 * @param options 설정 옵션
 * @returns 방향 및 트리거 관련 함수들
 */
export function useKeyboardInputHandler(options: {
  /** 발사 액션 키 이름 (예: "action1", "action2") */
  fireAction?: string;
  /** 플레이어 RigidBody 참조 (방향 계산에 사용) */
  playerRef?: MutableRefObject<Object3D | undefined | null>;
  /** Y 축 방향 고정 여부 (true면 수평 방향만 계산) */
  lockYAxis?: boolean;
  /** 방향 벡터로 현재 속도를 사용할지 여부 */
  useVelocityAsDirection?: boolean;
  /** 기본 전방 방향 (RigidBody가 없거나 방향을 얻을 수 없을 때 사용) */
  defaultDirection?: Vector3;
}) {
  const {
    fireAction = "action1",
    playerRef,
    lockYAxis = true,
    useVelocityAsDirection = false,
    defaultDirection = new Vector3(0, 0, -1), // 기본적으로 z축 음의 방향
  } = options;

  // @react-three/drei의 키보드 컨트롤 훅 사용 (발사 트리거용)
  const [subscribeKeys, getKeys] = useKeyboardControls();

  /**
   * RigidBody에서 현재 방향 벡터 계산
   * @returns 정규화된 방향 벡터
   */
  const calculateDirection = useCallback(() => {
    // playerRef가 없거나 RigidBody가 없는 경우 기본 방향 반환
    if (!playerRef?.current) {
      return defaultDirection.clone();
    }

    const player = playerRef.current;
    let direction = new Vector3();

    if (useVelocityAsDirection) {
      // RigidBody의 속도 벡터를 방향으로 사용
      // @ts-ignore - 실제 코드에서는 RigidBody 타입에 맞게 조정 필요
      const velocity = player.linvel?.() || new Vector3();

      // 속도가 충분히 있는 경우 그 방향 사용
      if (velocity.length() > 0.1) {
        direction.copy(velocity).normalize();
      } else {
        // 속도가 거의 없는 경우 플레이어가 바라보는 방향 사용
        direction = getForwardDirection(player);
      }
    } else {
      // 속도와 무관하게 플레이어가 바라보는 방향 사용
      direction = getForwardDirection(player);
    }

    // Y축 잠금이 활성화된 경우 수평 방향만 사용
    if (lockYAxis) {
      direction.y = 0;
      if (direction.length() > 0) {
        direction.normalize();
      } else {
        direction.copy(defaultDirection);
      }
    }

    return direction;
  }, [playerRef, defaultDirection, useVelocityAsDirection, lockYAxis]);

  /**
   * 객체가 바라보는 전방 방향 벡터 계산
   * @param object 방향을 계산할 객체
   * @returns 정규화된 전방 벡터
   */
  const getForwardDirection = useCallback((object: Object3D) => {
    // 객체의 회전을 사용하여 전방 벡터 계산
    const quaternion = new Quaternion();
    object.getWorldQuaternion(quaternion);

    // 기본 전방 벡터 (Object3D에서는 보통 z축 음의 방향)
    const forward = new Vector3(0, 0, -1);
    forward.applyQuaternion(quaternion);

    return forward;
  }, []);

  /**
   * 지정된 목표 위치까지의 방향 벡터 계산
   * @param startPosition 시작 위치
   * @param distance 목표 거리
   * @returns 목표 위치 벡터
   */
  const calculateTargetPosition = useCallback(
    (startPosition: Vector3, distance: number = 50) => {
      const direction = calculateDirection();
      return new Vector3()
        .copy(startPosition)
        .addScaledVector(direction, distance);
    },
    [calculateDirection]
  );

  /**
   * 발사 키가 눌렸는지 확인
   * @returns 발사 키 눌림 상태
   */
  const isFireTriggered = useCallback(() => {
    const keys = getKeys();
    return !!keys[fireAction];
  }, [getKeys, fireAction]);

  /**
   * 지정된 키가 눌렸는지 확인
   * @param keyName 확인할 키 이름
   * @returns 키 눌림 상태
   */
  const isKeyPressed = useCallback(
    (keyName: string) => {
      const keys = getKeys();
      return !!keys[keyName];
    },
    [getKeys]
  );

  /**
   * 발사 키 입력 구독 함수
   * @param callback 키 상태 변경 시 호출할 콜백
   * @returns 구독 해제 함수
   */
  const subscribeToFireAction = useCallback(
    (callback: (pressed: boolean) => void) => {
      return subscribeKeys(
        (state) => state[fireAction],
        (pressed) => callback(pressed)
      );
    },
    [subscribeKeys, fireAction]
  );

  return {
    /** RigidBody 기반 방향 벡터 계산 */
    calculateDirection,
    /** 시작점에서 계산된 방향으로의 목표점 계산 */
    calculateTargetPosition,
    /** 발사 키가 눌렸는지 확인 */
    isFireTriggered,
    /** 특정 키가 눌렸는지 확인 */
    isKeyPressed,
    /** 발사 키 입력 이벤트 구독 */
    subscribeToFireAction,
    /** 객체의 전방 방향 계산 */
    getForwardDirection,
  };
}
```

### 사용 예시:

```typescript
// Player.tsx에서 사용 예시
function Player() {
  const playerRef = useRef<Object3D>(null);
  const rigidBodyRef = useRef<RigidBody>(null);

  // 플레이어 위치 가져오기
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 키보드 입력 핸들러 사용 (RigidBody 방향 기반)
  const { calculateDirection, calculateTargetPosition, subscribeToFireAction } =
    useKeyboardInputHandler({
      fireAction: "action1", // 1번 키로 발사
      playerRef: rigidBodyRef, // RigidBody 참조 전달
      lockYAxis: true, // 수평 방향만 사용
      useVelocityAsDirection: false, // 속도 대신 바라보는 방향 사용
    });

  // 발사 효과 생성 함수
  const shootProjectile = useCallback(() => {
    const startPos = getPlayerPosition();
    const endPos = calculateTargetPosition(startPos, 30);

    // 이펙트 스토어에 발사 요청
    addEffect(EffectType.BULLET, account, {
      startPosition: startPos,
      endPosition: endPos,
      speed: 20,
    });
  }, [getPlayerPosition, calculateTargetPosition, addEffect, account]);

  // 발사 키 입력 구독
  useEffect(() => {
    return subscribeToFireAction((pressed) => {
      if (pressed) {
        shootProjectile();
      }
    });
  }, [subscribeToFireAction, shootProjectile]);

  return (
    <RigidBody ref={rigidBodyRef} position={[0, 1, 0]}>
      <mesh ref={playerRef}>
        <boxGeometry args={[1, 1, 1]} />
        <meshStandardMaterial color="blue" />
      </mesh>
    </RigidBody>
  );
}
```

이 코드는 키보드 입력 대신 플레이어의 RigidBody 방향을 기반으로 발사 방향을 계산합니다. RigidBody의 바라보는 방향이나 속도 벡터를 방향으로 사용할 수 있는 옵션을 제공하며, 키보드 입력은 발사 트리거로만 사용합니다.

---

_**User**_

투사체의 targetPosition(endPosition)을 키보드 입력 기능에서 계산하는게 맞을지 의문이 듭니다. 깊게 생각해보고 의견을 제시해주세요.

---

_**Assistant**_

---

입력 기능과 목표 위치 계산의 책임 분리에 대한 깊은 고민이 필요한 질문입니다. 아래와 같은 분석을 제시합니다:

## 현재 접근법의 문제점

현재 `useKeyboardInputHandler`에서 `targetPosition`을 계산하는 것은 다음 이유로 문제가 될 수 있습니다:

1. **관심사 분리 원칙 위반**:

   - 입력 시스템은 "사용자 의도 감지"에 집중해야 함
   - 목표 위치 계산은 "투사체 로직"에 속하는 책임

2. **유연성 제한**:

   - 다양한 발사 패턴은 각기 다른 목표 계산 로직이 필요함
   - 예: 곡선 발사는 중간 제어점, 추적 미사일은 목표물 위치 등

3. **코드 중복**:
   - 각 발사 패턴 모듈에서 입력 핸들러를 사용할 때마다 목표 계산 로직이 중복됨

## 개선된 접근법 제안

입력 처리와 목표 계산을 명확히 분리하는 것이 바람직합니다:

```typescript
// 입력 핸들러: 방향 벡터만 제공
export function useKeyboardInputHandler(options: {
  fireAction?: string;
  playerRef?: MutableRefObject<Object3D | undefined | null>;
}) {
  // ...구현...

  return {
    // 방향 벡터만 제공 (목표 위치 계산 제외)
    getDirectionVector,
    isFireTriggered,
    subscribeToFireAction,
  };
}

// 발사 모듈: 목표 위치 계산 포함
export function useStraightLineProjectile(options: {
  startPosition: Vector3 | (() => Vector3);
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  inputHandler?: ReturnType<typeof useKeyboardInputHandler>;
  targetDistance?: number;
}) {
  const {
    inputHandler,
    targetDistance = 50,
    // ...다른 옵션들...
  } = options;

  // 직선 발사의 목표 위치 계산
  const calculateTargetPosition = useCallback(() => {
    const startPos = getStartPosition();
    const direction = inputHandler.getDirectionVector();
    return new Vector3()
      .copy(startPos)
      .addScaledVector(direction, targetDistance);
  }, [inputHandler, targetDistance, getStartPosition]);

  // 발사 로직
  const fireProjectile = useCallback(() => {
    addEffect(projectileType, account, {
      startPosition: getStartPosition(),
      endPosition: calculateTargetPosition(),
      speed: projectileSpeed,
    });
  }, [
    calculateTargetPosition,
    getStartPosition,
    projectileType,
    projectileSpeed,
  ]);

  // ...나머지 구현...
}
```

## 이 접근법의 장점

1. **명확한 책임 분리**:

   - 입력 핸들러: 사용자 의도(방향, 트리거) 감지
   - 발사 모듈: 투사체 유형별 목표 계산 및 생성

2. **향상된 유연성**:

   - 각 발사 패턴은 자체 목표 계산 로직 구현 가능
   - 예: 곡선 발사는 높이 파라미터 추가, 산탄은 여러 목표 계산 등

3. **재사용성 증대**:

   - 동일한 입력 핸들러를 다양한 발사 패턴에서 공유
   - 발사 패턴별 로직은 해당 모듈에 캡슐화

4. **확장성 향상**:
   - 마우스 입력, 게임패드 등 다른 입력 핸들러 쉽게 교체 가능
   - 입력 변경해도 발사 패턴 로직은 유지

이처럼 입력 핸들러는 "방향 벡터"만 제공하고, 실제 목표 위치 계산은 각 발사 패턴 모듈에서 담당하는 것이 설계 원칙에 더 부합합니다.

---

_**User**_

입력 처리와 목표 계산을 명확히 분리한 버전의 입력처리 코드스니펫을 작성해주세요.

---

_**Assistant**_

---

```typescript
// src/hooks/useKeyboardInputHandler.ts
import { useCallback, MutableRefObject } from "react";
import { Vector3, Object3D, Quaternion } from "three";
import { useKeyboardControls } from "@react-three/drei";
import { RigidBody } from "@dimforge/rapier3d-compat";

/**
 * 키보드 입력을 처리하고 RigidBody 기반 방향 벡터와 발사 트리거를 제공하는 훅
 * 목표 위치 계산은 포함하지 않고 방향 정보만 제공합니다.
 *
 * @param options 설정 옵션
 * @returns 방향 벡터 및 입력 트리거 관련 함수들
 */
export function useKeyboardInputHandler(options: {
  /** 발사 액션 키 이름 (예: "action1", "action2") */
  fireAction?: string;
  /** 플레이어 RigidBody 참조 (방향 계산에 사용) */
  playerRef?: MutableRefObject<Object3D | undefined | null>;
  /** Y 축 방향 고정 여부 (true면 수평 방향만 계산) */
  lockYAxis?: boolean;
  /** 방향 벡터로 현재 속도를 사용할지 여부 */
  useVelocityAsDirection?: boolean;
  /** 기본 전방 방향 (RigidBody가 없거나 방향을 얻을 수 없을 때 사용) */
  defaultDirection?: Vector3;
}) {
  const {
    fireAction = "action1",
    playerRef,
    lockYAxis = true,
    useVelocityAsDirection = false,
    defaultDirection = new Vector3(0, 0, -1), // 기본적으로 z축 음의 방향
  } = options;

  // @react-three/drei의 키보드 컨트롤 훅 사용 (발사 트리거용)
  const [subscribeKeys, getKeys] = useKeyboardControls();

  /**
   * 객체가 바라보는 전방 방향 벡터 계산
   * @param object 방향을 계산할 객체
   * @returns 정규화된 전방 벡터
   */
  const getForwardDirection = useCallback((object: Object3D) => {
    const quaternion = new Quaternion();
    object.getWorldQuaternion(quaternion);

    // 기본 전방 벡터 (Object3D에서는 보통 z축 음의 방향)
    const forward = new Vector3(0, 0, -1);
    forward.applyQuaternion(quaternion);

    return forward;
  }, []);

  /**
   * RigidBody에서 현재 방향 벡터 계산
   * 발사 방향으로 사용할 정규화된 벡터를 반환합니다.
   * @returns 정규화된 방향 벡터
   */
  const getDirectionVector = useCallback(() => {
    // playerRef가 없거나 RigidBody가 없는 경우 기본 방향 반환
    if (!playerRef?.current) {
      return defaultDirection.clone();
    }

    const player = playerRef.current;
    let direction = new Vector3();

    if (useVelocityAsDirection) {
      // RigidBody의 속도 벡터를 방향으로 사용
      // @ts-ignore - 실제 코드에서는 RigidBody 타입에 맞게 조정 필요
      const velocity = player.linvel?.() || new Vector3();

      // 속도가 충분히 있는 경우 그 방향 사용
      if (velocity.length() > 0.1) {
        direction.copy(velocity).normalize();
      } else {
        // 속도가 거의 없는 경우 플레이어가 바라보는 방향 사용
        direction = getForwardDirection(player);
      }
    } else {
      // 속도와 무관하게 플레이어가 바라보는 방향 사용
      direction = getForwardDirection(player);
    }

    // Y축 잠금이 활성화된 경우 수평 방향만 사용
    if (lockYAxis) {
      direction.y = 0;
      if (direction.length() > 0) {
        direction.normalize();
      } else {
        direction.copy(defaultDirection);
      }
    }

    return direction;
  }, [
    playerRef,
    defaultDirection,
    useVelocityAsDirection,
    lockYAxis,
    getForwardDirection,
  ]);

  /**
   * 발사 키가 눌렸는지 확인
   * @returns 발사 키 눌림 상태
   */
  const isFireTriggered = useCallback(() => {
    const keys = getKeys();
    return !!keys[fireAction];
  }, [getKeys, fireAction]);

  /**
   * 지정된 키가 눌렸는지 확인
   * @param keyName 확인할 키 이름
   * @returns 키 눌림 상태
   */
  const isKeyPressed = useCallback(
    (keyName: string) => {
      const keys = getKeys();
      return !!keys[keyName];
    },
    [getKeys]
  );

  /**
   * 발사 키 입력 구독 함수
   * @param callback 키 상태 변경 시 호출할 콜백
   * @returns 구독 해제 함수
   */
  const subscribeToFireAction = useCallback(
    (callback: (pressed: boolean) => void) => {
      return subscribeKeys(
        (state) => state[fireAction],
        (pressed) => callback(pressed)
      );
    },
    [subscribeKeys, fireAction]
  );

  return {
    /** RigidBody 기반 방향 벡터 얻기 (발사 방향으로 사용) */
    getDirectionVector,
    /** 발사 키가 눌렸는지 확인 */
    isFireTriggered,
    /** 특정 키가 눌렸는지 확인 */
    isKeyPressed,
    /** 발사 키 입력 이벤트 구독 */
    subscribeToFireAction,
    /** 키보드 상태 직접 접근 (필요시) */
    getKeys,
  };
}
```

### 사용 예시:

```typescript
// Player.tsx에서 사용 예시
function Player() {
  const playerRef = useRef<Object3D>(null);
  const rigidBodyRef = useRef<RigidBody>(null);

  // 키보드 입력 핸들러 사용 - 방향 정보만 추출
  const { getDirectionVector, subscribeToFireAction } = useKeyboardInputHandler(
    {
      fireAction: "action1", // 1번 키로 발사
      playerRef: rigidBodyRef, // RigidBody 참조 전달
      lockYAxis: true, // 수평 방향만 사용
      useVelocityAsDirection: false, // 속도 대신 바라보는 방향 사용
    }
  );

  // 발사 효과 생성 함수 - 여기서 목표 위치 계산
  const shootProjectile = useCallback(() => {
    // 시작 위치 계산
    const startPos =
      playerRef.current?.position.clone() || new Vector3(0, 1, 0);

    // 방향 벡터 얻기 (입력 핸들러로부터)
    const direction = getDirectionVector();

    // 목표 위치 계산 (발사 모듈에서 수행하는 로직)
    const targetDistance = 30;
    const endPos = new Vector3()
      .copy(startPos)
      .addScaledVector(direction, targetDistance);

    // 이펙트 스토어에 발사 요청
    addEffect(EffectType.BULLET, account, {
      startPosition: startPos,
      endPosition: endPos,
      speed: 20,
    });
  }, [getDirectionVector, addEffect, account]);

  // 발사 키 입력 구독
  useEffect(() => {
    return subscribeToFireAction((pressed) => {
      if (pressed) {
        shootProjectile();
      }
    });
  }, [subscribeToFireAction, shootProjectile]);

  return (
    <RigidBody ref={rigidBodyRef}>
      <mesh ref={playerRef} position={[0, 1, 0]}>
        <boxGeometry args={[1, 1, 1]} />
        <meshStandardMaterial color="blue" />
      </mesh>
    </RigidBody>
  );
}
```

이 코드는 입력 처리와 목표 계산을 명확히 분리합니다:

1. `useKeyboardInputHandler`는 오직 방향 벡터와 트리거 상태만 제공
2. 실제 목표 위치 계산은 발사 로직이나 발사 모듈에서 수행
3. 이 분리를 통해 다양한 발사 패턴 모듈이 동일한 입력 핸들러를 사용하면서도 자체적인 목표 계산 로직을 가질 수 있음

이런 구조는 단일 책임 원칙을 따르며, 코드의 재사용성과 유지보수성을 향상시킵니다.

---

_**User**_

방향을 계산하는것도 위반되는건 아닌지 의문이 듭니다.

---

_**Assistant**_

---

매우 통찰력 있는 지적입니다. 깊이 분석해보면 방향 계산도 입력 핸들러의 책임 범위를 벗어날 수 있습니다.

## 책임 분리의 관점에서 다시 생각하기

이상적인 관점에서 각 컴포넌트의 책임은 다음과 같이 구분되어야 합니다:

1. **입력 핸들러**: 순수하게 입력 상태만 제공

   - 키 눌림 상태
   - 입력 이벤트 구독

2. **캐릭터 컨트롤러/플레이어 시스템**: 플레이어 상태 관리

   - 현재 바라보는 방향
   - 이동 속도 및 방향
   - RigidBody 상태

3. **발사 시스템**: 투사체 생성 및 설정
   - 입력과 플레이어 상태 결합
   - 발사 방향 계산
   - 투사체 생성

## 개선된 접근법

아래는 책임을 더 명확히 분리한 코드 구조입니다:

```typescript
// 1. 순수 입력 핸들러 - 입력 상태만 제공
export function useKeyboardInput(options: { fireAction?: string }) {
  const { fireAction = "action1" } = options;
  const [subscribeKeys, getKeys] = useKeyboardControls();

  return {
    // 키 눌림 상태 확인
    isKeyPressed: (key: string) => !!getKeys()[key],

    // 발사 키 구독
    subscribeToFireAction: (callback: (pressed: boolean) => void) => {
      return subscribeKeys((state) => state[fireAction], callback);
    },

    // 원시 키 상태 (필요시에만)
    getKeys,
  };
}

// 2. 플레이어 방향 관리 - 플레이어 상태 제공
export function usePlayerDirection(
  playerRef: MutableRefObject<Object3D | null>
) {
  // 플레이어 전방 방향 얻기
  const getPlayerForwardDirection = useCallback(() => {
    if (!playerRef.current) return new Vector3(0, 0, -1);

    const quaternion = new Quaternion();
    playerRef.current.getWorldQuaternion(quaternion);

    const forward = new Vector3(0, 0, -1);
    forward.applyQuaternion(quaternion);

    // 필요시 Y축 평면화
    forward.y = 0;
    if (forward.length() > 0) {
      forward.normalize();
    } else {
      forward.set(0, 0, -1);
    }

    return forward;
  }, [playerRef]);

  // 플레이어 속도 방향 얻기 (필요시)
  const getPlayerVelocityDirection = useCallback(
    () => {
      // RigidBody 속도 기반 로직...
      return new Vector3(/* 속도 방향 */);
    },
    [
      /* 의존성 */
    ]
  );

  return {
    getPlayerForwardDirection,
    getPlayerVelocityDirection,
  };
}

// 3. 발사 모듈 - 위 두 시스템을 조합하여 사용
export function useStraightLineProjectile(options: {
  startPosition: Vector3 | (() => Vector3);
  getDirection: () => Vector3; // 외부에서 방향 함수 주입
  fireAction?: string;
  projectileSpeed?: number;
  projectileType?: EffectType;
  targetDistance?: number;
}) {
  const {
    getDirection,
    startPosition,
    targetDistance = 30,
    projectileType = EffectType.BULLET,
    projectileSpeed = 20,
    fireAction = "action1",
  } = options;

  // 입력 처리
  const { subscribeToFireAction } = useKeyboardInput({ fireAction });

  // 발사 함수
  const fireProjectile = useCallback(() => {
    const startPos =
      typeof startPosition === "function" ? startPosition() : startPosition;
    const direction = getDirection(); // 외부에서 주입된 방향 함수 사용
    const endPos = new Vector3()
      .copy(startPos)
      .addScaledVector(direction, targetDistance);

    addEffect(projectileType, account, {
      startPosition: startPos,
      endPosition: endPos,
      speed: projectileSpeed,
    });
  }, [
    getDirection,
    startPosition,
    targetDistance,
    projectileType,
    projectileSpeed,
  ]);

  // 키 입력에 발사 함수 연결
  useEffect(() => {
    return subscribeToFireAction((pressed) => {
      if (pressed) fireProjectile();
    });
  }, [subscribeToFireAction, fireProjectile]);

  return { fireProjectile };
}
```

## 사용 예시

```typescript
function Player() {
  const playerRef = useRef<Object3D>(null);

  // 플레이어 방향 관리
  const { getPlayerForwardDirection } = usePlayerDirection(playerRef);

  // 직선 발사 시스템 - 플레이어 방향 함수 주입
  useStraightLineProjectile({
    startPosition: () => playerRef.current?.position.clone() || new Vector3(),
    getDirection: getPlayerForwardDirection, // 방향 함수 주입
    projectileType: EffectType.BULLET,
    targetDistance: 30,
  });

  // ... 렌더링 코드 ...
}
```

이 접근법의 장점:

1. **완전한 책임 분리**:

   - 입력 시스템: 오직 입력 상태만 처리
   - 플레이어 시스템: 플레이어 상태 및 방향 관리
   - 발사 시스템: 입력과 방향을 조합하여 투사체 생성

2. **의존성 주입**:

   - 방향 계산 함수를 외부에서 주입받아 사용
   - 테스트 용이성 및 유연성 증가

3. **재사용성 향상**:
   - 각 시스템은 단일 책임에 집중하여 다양한 맥락에서 재사용 가능
   - 방향 계산 로직 변경 시 입력/발사 시스템 코드 수정 불필요

이처럼 책임을 더 명확하게 분리하면 코드의 유지보수성과 확장성이 향상됩니다.

---

_**User**_

딱 입력상태만 남긴다고했을때 codebase를 기반으로 생각해봤을때 입력처리 시스템을 코드스니펫으로 제공하는 의미가 있을까요? 깊에 고민해보고 답변해주세요.

---

_**Assistant**_

---

순수 입력 상태만 제공하는 입력 처리 시스템의 코드 스니펫 가치에 대해 깊이 고민해 보았습니다:

## 분석

현재 코드베이스를 고려했을 때:

1. **이미 `useKeyboardControls` 사용 중**:

   - `@react-three/drei`의 `useKeyboardControls`는 이미 키 상태 확인과 구독 기능 제공
   - `src/constants/controls.ts`에 키 매핑 이미 정의됨

2. **순수 입력 상태만 제공하는 코드의 가치**:
   - 기존 `useKeyboardControls`를 거의 그대로 래핑하는 수준
   - 새로운 추상화나 기능 추가가 거의 없음

## 결론

**VectorDB용 코드 스니펫으로서의 가치는 제한적입니다.** 이유는:

1. **낮은 추상화 가치**:

   ```typescript
   // 순수 입력 처리 스니펫은 사실상 이런 형태
   function useKeyboardInput(fireAction = "action1") {
     const [subscribeKeys, getKeys] = useKeyboardControls();

     return {
       isFirePressed: () => !!getKeys()[fireAction],
       subscribeToFire: (callback) =>
         subscribeKeys((state) => state[fireAction], callback),
     };
   }
   ```

   이는 `useKeyboardControls`를 직접 사용하는 것과 큰 차이가 없습니다.

2. **불필요한 중간 레이어**:

   - 입력 상태만 제공하는 레이어는 실질적인 부가가치가 낮음
   - 오히려 불필요한 간접 참조 추가

3. **VectorDB 최적화 관점**:
   - AI가 "총을 발사하는 코드"를 찾을 때 단순 입력 처리보다는 완전한 발사 시스템 구현이 더 유용함
   - 입력 처리보다 발사 로직에 집중하는 것이 가치 있음

## 대안 제안

1. **발사 시스템에 직접 통합**:

   ```typescript
   export function useStraightLineProjectile(options: {
     startPosition: Vector3 | (() => Vector3);
     fireAction?: string;
     // 기타 옵션들...
   }) {
     // 키보드 입력 직접 처리
     const [subscribeKeys, getKeys] = useKeyboardControls();

     // 발사 로직 구현
     // ...

     // 키 입력 구독
     useEffect(
       () => {
         return subscribeKeys(
           (state) => state[options.fireAction || "action1"],
           (pressed) => {
             if (pressed) fireProjectile();
           }
         );
       },
       [
         /* 의존성 */
       ]
     );

     return { fireProjectile };
   }
   ```

2. **방향 계산 포함한 의미 있는 모듈**:
   - 방향 계산 로직을 포함하는 것이 실용적 가치 증가
   - 그러나 목표 위치 계산은 발사 시스템에 남겨두는 것이 적절

따라서, 순수 입력 상태만 제공하는 개별 모듈보다는 발사 시스템 내에 직접 입력 처리 로직을 통합하거나, 방향 계산까지 포함한 더 의미 있는 모듈을 제공하는 것이 더 가치 있을 것입니다.

---

_**User**_

발사 시스템에 키보드입력을 처리하는건 절대 피해야합니다. 마우스로 쏠지 키보드로 쏠지 알수없는데 말이 안되는거 아닌가요?

---

_**Assistant**_

---

전적으로 동의합니다! 깊이 생각해보니 발사 시스템에 특정 입력 방식을 통합하는 것은 심각한 설계 오류입니다. 다음과 같은 명확한 문제가 있습니다:

1. **강한 결합**: 발사 시스템이 특정 입력 방식에 종속됨
2. **유연성 상실**: 다른 입력 방식으로 전환할 수 없음
3. **재사용성 저하**: 다른 입력 방식에서 동일한 발사 패턴 활용 불가
4. **테스트 어려움**: 입력 시뮬레이션이 필요해짐

## 개선된 접근법: 입력과 발사 분리

더 적절한 설계는 다음과 같은 계층적 구조입니다:

```
1. 입력 핸들러 (인터페이스)
   ├─ 키보드 입력 핸들러 (구현)
   ├─ 마우스 입력 핸들러 (구현)
   └─ 게임패드 입력 핸들러 (구현)

2. 발사 시스템 (입력 핸들러 주입받음)
   ├─ 직선 발사 모듈
   ├─ 산탄 발사 모듈
   └─ 곡선 발사 모듈
```

이 구조에서 다음 원칙을 따릅니다:

1. **입력 시스템은 표준화된 인터페이스 제공**:

   - 발사 의도 감지 (트리거)
   - 필요시 방향 정보 제공

2. **발사 시스템은 입력 핸들러 주입받음**:
   - 구체적인 입력 방식 알 필요 없음
   - 인터페이스를 통해 발사 의도만 받음

이 접근법은 소프트웨어 설계의 핵심 원칙인 "의존성 역전(Dependency Inversion)"과 "인터페이스 분리(Interface Segregation)"를 따릅니다.

결론적으로, 발사 시스템에 직접 입력 처리를 통합하는 것은 피해야 하며, 대신 입력 처리 모듈과 발사 시스템 모듈을 명확히 분리하고 표준화된 인터페이스로 연결해야 합니다.

---

_**User**_

자 이제 다시 돌아가서 현재 codebase 를 기반으로 생각해봤을때 키보드 입력 핸들러를 구현해야할까요?

---

_**Assistant**_

---

현재 코드베이스를 분석해본 결과, 키보드 입력 핸들러 구현의 필요성에 대해 다음과 같이 판단합니다:

## 필요성 분석

1. **현재 코드베이스 상태**:

   - `src/constants/controls.ts`에 이미 키보드 매핑 정의되어 있음
   - `@react-three/drei`의 `KeyboardControls` 기능 활용 중
   - `EffectContainer.tsx`에서 이펙트 시스템 구현되어 있음

2. **직접적인 사용 가능성**:

   ```typescript
   // 이미 이런 식으로 키보드 입력 활용 가능
   const [subscribeKeys, getKeys] = useKeyboardControls();

   useEffect(() => {
     return subscribeKeys(
       (state) => state.action1, // 이미 정의된 키 매핑 사용
       (pressed) => {
         if (pressed) {
           /* 발사 로직 */
         }
       }
     );
   }, []);
   ```

3. **현실적 고려사항**:
   - 단순히 키 눌림 감지만 필요하다면 기존 기능으로 충분함
   - 그러나 입력 처리가 여러 발사 패턴에서 반복될 가능성 있음

## 결론

**최소한의 중간 추상화 레이어는 유용할 수 있습니다.**

```typescript
// src/hooks/useInputTrigger.ts
import { useEffect, useCallback } from "react";
import { useKeyboardControls } from "@react-three/drei";

/**
 * 발사 트리거 감지를 위한 간단한 훅
 * 키보드 입력을 발사 의도로 변환합니다.
 */
export function useInputTrigger(options: {
  /** 발사 액션 키 이름 (예: "action1", "action2") */
  triggerAction?: string;
  /** 사용자 정의 발사 처리 함수 */
  onTrigger?: () => void;
}) {
  const { triggerAction = "action1", onTrigger } = options;
  const [subscribeKeys] = useKeyboardControls();

  // 발사 액션 구독
  useEffect(() => {
    if (!onTrigger) return;

    return subscribeKeys(
      (state) => state[triggerAction],
      (pressed) => {
        if (pressed) onTrigger();
      }
    );
  }, [subscribeKeys, triggerAction, onTrigger]);

  return {
    // 필요시 다른 핸들러와 호환되는 함수 구조 제공
    bindTriggerHandler: (handler: () => void) => {
      return { onClick: handler }; // 마우스 이벤트와 호환되는 형태
    },
  };
}
```

이 간단한 훅은 다음과 같은 이점을 제공합니다:

1. **최소한의 추상화**: 반복되는 구독 코드 제거
2. **의도 명확화**: "키 누름"이 아닌 "발사 의도"에 집중
3. **확장 가능성**: 나중에 다른 입력 방식과 통합 가능한 구조

실제 발사 시스템에서는 다음과 같이 사용할 수 있습니다:

```typescript
function useStraightLineProjectile(options) {
  // 발사 함수 정의
  const fireProjectile = useCallback(() => {
    // 투사체 발사 로직...
  }, []);

  // 입력 트리거 연결
  useInputTrigger({
    triggerAction: options.fireAction || "action1",
    onTrigger: fireProjectile,
  });

  return { fireProjectile };
}
```

이 접근법은 불필요하게 복잡한 추상화 없이도 입력 처리와 발사 로직 분리의 이점을 제공합니다.

---

_**User**_

다시 생각해보니 키보드 입력시스템이 아니라 투사체를 쏘기위한 키보드 입력시스템을 구현하는것이 맞는것같습니다. 이를 고려하여 다시 한번 깊이 생각해보고 투사체 발사 키보드 입력 시스템을 어떻게 구현해야할지 솔루션을 제시해주세요.

---

_**Assistant**_

---

# 투사체 발사를 위한 키보드 입력 시스템 솔루션

코드베이스를 기반으로 투사체 발사에 특화된 키보드 입력 시스템을 설계해 보았습니다. 이 시스템은 단순한 키 입력 처리가 아니라, 투사체 발사라는 특정 목적에 최적화된 추상화를 제공합니다.

## 핵심 설계 원칙

1. **발사 의도 중심**: 키 입력 자체가 아닌 '발사 의도'를 표현
2. **방향 결정 포함**: 투사체 발사에 필요한 방향 정보 제공
3. **모듈 독립성**: 발사 시스템과 분리된 독립적 모듈
4. **인터페이스 통일**: 다른 입력 방식과 호환 가능한 인터페이스

## 코드 솔루션

```typescript
// src/hooks/useKeyboardProjectileTrigger.ts
import { useEffect, useCallback, useRef, MutableRefObject } from "react";
import { Vector3, Object3D, Quaternion } from "three";
import { useKeyboardControls } from "@react-three/drei";

/**
 * 투사체 발사를 위한 키보드 입력 처리 시스템
 * 발사 트리거와 방향 결정을 위한 특화된 훅
 */
export function useKeyboardProjectileTrigger(options: {
  /** 발사 트리거로 사용할 키 액션 */
  fireAction?: string;
  /** 플레이어 객체 참조 (방향 계산에 사용) */
  playerRef?: MutableRefObject<Object3D | null>;
  /** Y축 방향 고정 여부 */
  lockYAxis?: boolean;
}) {
  const { fireAction = "action1", playerRef, lockYAxis = true } = options;

  // 키보드 입력 훅
  const [subscribeKeys, getKeys] = useKeyboardControls();

  // 마지막 계산된 방향 캐싱
  const lastDirectionRef = useRef(new Vector3(0, 0, -1));

  /**
   * 플레이어가 바라보는 방향 벡터 계산
   */
  const getFireDirection = useCallback(() => {
    // playerRef가 없는 경우 기본 방향 사용
    if (!playerRef?.current) {
      return lastDirectionRef.current.clone();
    }

    // 플레이어 회전에서 전방 방향 계산
    const quaternion = new Quaternion();
    playerRef.current.getWorldQuaternion(quaternion);

    const direction = new Vector3(0, 0, -1);
    direction.applyQuaternion(quaternion);

    // Y축 고정 옵션 적용
    if (lockYAxis) {
      direction.y = 0;
      if (direction.length() > 0) {
        direction.normalize();
      } else {
        direction.set(0, 0, -1);
      }
    }

    // 계산된 방향 캐싱
    lastDirectionRef.current.copy(direction);

    return direction;
  }, [playerRef, lockYAxis]);

  /**
   * 발사 트리거 이벤트를 구독
   * @param onFire 발사 시 호출할 콜백
   * @returns 구독 해제 함수
   */
  const subscribeTrigger = useCallback(
    (onFire: (direction: Vector3) => void) => {
      return subscribeKeys(
        (state) => state[fireAction],
        (pressed) => {
          if (pressed) {
            // 발사 시점의 방향 계산하여 콜백에 전달
            const direction = getFireDirection();
            onFire(direction);
          }
        }
      );
    },
    [subscribeKeys, fireAction, getFireDirection]
  );

  /**
   * 수동으로 발사 여부 확인 (필요시)
   */
  const isTriggerPressed = useCallback(() => {
    const keys = getKeys();
    return !!keys[fireAction];
  }, [getKeys, fireAction]);

  return {
    /** 발사 트리거 구독 (방향 정보 포함) */
    subscribeTrigger,
    /** 현재 발사 방향 계산 */
    getFireDirection,
    /** 발사 키 눌림 상태 확인 */
    isTriggerPressed,
  };
}
```

## 사용 예시

```typescript
// 직선 발사 모듈에서 사용 예시
function useStraightLineProjectile(options: {
  playerRef: MutableRefObject<Object3D | null>;
  startPositionFn: () => Vector3;
  projectileType?: EffectType;
  projectileSpeed?: number;
  fireAction?: string;
  targetDistance?: number;
}) {
  const {
    playerRef,
    startPositionFn,
    projectileType = EffectType.BULLET,
    projectileSpeed = 20,
    fireAction = "action1",
    targetDistance = 30,
  } = options;

  // 이펙트 스토어
  const addEffect = useEffectStore((state) => state.addEffect);
  const { account } = useGameServer();

  // 키보드 발사 트리거 사용
  const { subscribeTrigger } = useKeyboardProjectileTrigger({
    fireAction,
    playerRef,
    lockYAxis: true,
  });

  // 투사체 발사 함수
  const fireProjectile = useCallback(
    (direction: Vector3) => {
      const startPos = startPositionFn();
      const endPos = new Vector3()
        .copy(startPos)
        .addScaledVector(direction, targetDistance);

      addEffect(projectileType, account, {
        startPosition: startPos,
        endPosition: endPos,
        speed: projectileSpeed,
      });
    },
    [
      startPositionFn,
      targetDistance,
      addEffect,
      projectileType,
      projectileSpeed,
      account,
    ]
  );

  // 발사 트리거 구독
  useEffect(() => {
    return subscribeTrigger(fireProjectile);
  }, [subscribeTrigger, fireProjectile]);

  // 필요시 수동 발사 기능 노출
  return { fireProjectile };
}

// 실제 사용 예시
function Player() {
  const playerRef = useRef<Object3D>(null);

  // 플레이어 위치 얻기
  const getPlayerPosition = useCallback(() => {
    return playerRef.current?.position.clone() || new Vector3(0, 1, 0);
  }, []);

  // 직선 발사 사용
  useStraightLineProjectile({
    playerRef,
    startPositionFn: getPlayerPosition,
    projectileType: EffectType.BULLET,
    fireAction: "action1", // "1" 키로 발사
  });

  return (
    <mesh ref={playerRef}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="blue" />
    </mesh>
  );
}
```

## 이 설계의 장점

1. **목적 특화**: 단순한 키보드 입력 처리가 아닌, 투사체 발사에 필요한 의미 있는 추상화 제공
2. **책임 범위 명확**: 발사 트리거 감지와 방향 계산이라는 명확한 책임 부여
3. **재사용성**: 다양한 발사 패턴 모듈에서 일관되게 사용 가능
4. **유연성**: `playerRef`를 통해 플레이어 객체 참조를 받아 방향 계산 가능
5. **캡슐화**: 키보드 입력 처리 세부사항을 캡슐화하여 발사 시스템 단순화

이 설계는 투사체 발사를 위한 키보드 입력 처리에 초점을 맞춘 특화된 시스템으로, 단순한 키 입력 감지를 넘어 발사 의도와 방향이라는 개념을 제공하여 발사 시스템과 깔끔하게 통합될 수 있습니다.

---
